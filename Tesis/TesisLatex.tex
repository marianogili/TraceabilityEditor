\documentclass[a4paper,12pt,oneside]{book}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{graphicx}

\newcommand{\grad}{\hspace{-2mm}$\phantom{a}^{\circ}$}


\author{Mariano Gabriel Gili}
\title{Tesis}
\date{\today}


\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%     Título           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \maketitle

\frontmatter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%     Índices          %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\listoffigures


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%    Agradecimientos    %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Agradecimientos}


Agradezco a todos...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%    Introducción       %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introducción}


En la Ingeniería de Software Dirigida por Modelos (MDE - Model-Driven Engineering) se define al modelo como principal artefacto que toma participación a lo largo de todas las tareas/procesos de la ingeniería de software – análisis, diseño, desarrollo, pruebas, mantenimiento, etc. Una implementación particular propuesta  que sigue esta idea es la Arquitectura Dirigida por Modelos (MDA - Model Driven Architecture) definida por el Object Management Group (OMG), cuyo ciclo de proceso de desarrollo está basado enteramente en el uso de modelos formales y transformaciones que se realizan sobre dichos modelos. Una característica muy importante de todo proceso de desarrollo dirigido por modelos (MDD – Model-Driven Development) es lo que se conoce como “posibilidad de rastreo” (o de ahora en más en inglés traceability), que ayuda y toma parte en todo lo que respecta a las relaciones que existen entre cada uno de los artefactos productos del proceso de desarrollo.

Cuando nos referimos al término artefacto, hablamos por ejemplo de un requerimiento de sistema, un componente de software, un caso de prueba, entre otros. El mantenimiento y la definición de las relaciones y dependencias que existen entre los artefactos no es una tarea fácil, el mismo ha sido un desafío desde principios de 1970.

En el presente documento de tesis se abordará el tema de traceability, luego se presentará un análisis de los distintos problemas que aún se encuentran abiertos como así también un conjunto de soluciones encontradas a lo largo de la investigación. Finalmente, se elaborará un esquema de traceability con el fin de contribuir en la solución de alguno de los problemas nombrados.




\chapter{Objetivos}


El objetivo del trabajo de tesis propuesto comprende, por un lado, una introducción al tema de traceability conjunto con un análisis de los problemas que aún se encuentran abiertos en su ámbito en MDE, seguido de la elaboración de un esquema de traceability que contribuya en la solución de dichos problemas.

También se diseñará e implementará una herramienta que pueda ser integrada a otra de desarrollo MDE, y asista al desarrollador automatizando el proceso de definición de trazas o links entre elementos de los modelos origen y destino. Esta solución proveerá un mapa de transformaciones que permitirá determinar la procedencia de cada ítem del modelo destino, y su correspondiente origen en el modelo fuente.


\mainmatter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%    Traceability       %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Traceability}

\section{Introducción}

Según el Glosario Estándar de Términos de la Ingeniería de Software del IEEE \cite{IEEE} la noción de traceability se define como: El grado o nivel en el cual una relación puede ser establecida entre dos o más productos del proceso de desarrollo, especialmente entre productos que tengan una relación de predecesor-sucesor o principal-secundario; por ejemplo el grado en el cual el requerimiento y el diseño de un componente de software se corresponden. La definición anterior fue dada por “the requirements management community”, para nosotros, que necesitamos un punto de vista maś cercano al contexto de MDD, traceability es un término usado para describir cualquiera de las complejas relaciones lógicas que existen entre los distintos artefactos que se presentan en cualquier momento del ciclo de vida del desarrollo de software, el establecimiento de estas relaciones y/o el mantenimiento de las mismas.

Entre varios beneficios de traceability que enumeraremos mejor más adelante, podemos encontrar que ayuda a identificar las relaciones y dependencias que existen entre los artefactos de software. También traceability es crucial entre los requerimientos y su representación en los modelos para asegurar que el conjunto relevante de requerimientos fueron debidamente implementados en el código. Pero no solo traceability asegura la identificación de objetos y elementos relacionados, también puede facilitar el análisis de impactos de cambios durante el desarrollo de software.

Las relaciones de traceability pueden ser definidas de forma automática, por ejemplo producto de una transformación de modelos, o de forma manual como el caso de una relación de implementación entre un requerimiento y un componente de software.

En la ingeniería de software encontramos dos usos o semánticas principales que dependen del contexto de traceability:

\begin{itemize}

\item Traceability en la ingeniería de requerimientos: donde se guarda un requerimiento desde su definición hasta su implementación. En más detalle según \cite{GotelFinkelstein} se refiere a la habilidad de describir y seguir la vida de los requerimientos en ambas direcciones, hacia delante y hacia atrás (forward and backward traceability). Desde los orígenes, pasando por el desarrollo y la especificación, hacia su posterior entrega y uso, y a través de todos los períodos de refinamiento e iteración de cualquiera de estas etapas.

\item Traceability en el Desarrollo Dirigido por Modelos: donde se almacenan principalmente las relaciones existentes entre los artefactos producto de las transformaciones de modelos.

\end{itemize}

\subsection{Beneficios}

A continuación se listan un conjunto de actividades de diferentes dominios de la ingeniería en las cuales el uso de traceability es muy beneficioso según \cite{BrcinaRiebisch} y \cite{GrammelVoigt}:

\begin{itemize}

\item   En el Análisis de sistemas: nos ayuda a entender la complejidad de un sistema navegando a lo largo del modelo de enlaces obtenidos por la ejecución de las distintas cadenas de transformación.   

\item    En el Análisis de cobertura: por ejemplo en el momento de ejecución de los casos de prueba, el uso de traceability es crucial para la hora de determinar si todos los requerimientos fueron cubiertos o tenidos en cuenta.

 \item   En el Análisis de impacto de cambios: traceability nos ayuda a ver cómo los cambios en un modelo repercutirán en los otros modelos relacionados; también el uso de traceability nos permite saber en cualquier momento el tipo de dependencia que existe entre las entidades relacionadas, lo cual ayuda a determinar la necesidad de un cambio.

 \item   En el Análisis de huérfanos: nos permitirá encontrar fácilmente los elementos huérfanos de un modelo dado que serán los artefactos que no se encuentren enlazados a ninguna traza.

 \item   En la Comprensión del software y la ingeniería inversa: crucial cuando sea necesario identificar todas las entidades relacionadas a una en particular, entender el tipo de relación existente, identificar las abstracciones, es decir los patrones de diseño, estilos de arquitectura, principios.

 \item   En el análisis de requerimiento: por ejemplo para identificar el artefacto particular que demanda una propiedad específica; encontrar y resolver un conjunto de requerimientos que se contradicen.

 \item   Apoyo en la toma de decisiones: para justificar una decisión dado que nos facilita entender qué factores y metas influyen en la misma; también traceability nos será muy útil en los momentos que se nos presenten distintas propuestas de solución en su análisis y evaluación.

\item    En la Configuración del sistema y versionado: en este momento el uso de traceability es beneficioso para identificar las restricciones entre los componentes, identificar los cambios necesarios para resolver una restricción, identificar las diferencias entre dos versiones distintas del mismo artefacto y su impacto en otros artefactos.

\end{itemize}


\subsection{Algunos inconvenientes}

Aunque las ventajas de traceability hoy día ya han sido identificadas, su puesta en práctica apenas ha quedado establecida. Las principales razones de lo anterior según \cite{GrammelVoigt} puede ser por lo siguiente:

\begin{itemize}

 \item   El alto costo de la creación y mantenimiento manual de la información de     traceability.

\item    La falta de heurísticas que determinen qué información de los enlaces deben ser grabados.

 \item   Discrepancias entre los distintos roles de usuarios de traceability, por ejemplo entre quienes crean los enlaces y quienes los usan.

\item    Carencia de soporte adecuado en las herramientas.

\item    Los artefactos son escritos en diferentes lenguajes, por ejemplo los requerimientos se escriben en lenguaje natural mientras que los programas en algún lenguaje de programación.

\item    Los artefactos describen el sistema de software en diferentes niveles de abstracción, los artefactos usados durante el diseño difiere de los usados en su implementación.

\end{itemize}

Más adelante en otro capítulo se presentará con más detalle los desafíos presentes en la implementación y el uso de traceability.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Problemas y Desafíos  %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Problemas y Desafíos}

En este capítulo vamos a describir los principales problemas y grandes desafíos que se encuentran abiertos en el ámbito de traceability a lo largo de distintos aspectos definidos por \cite{Excellence}. 

El capítulo se encuentra organizado principalmente por temas. Luego, para cada tema, se describen sus problemas y a continuación se listan los desafíos que resultan de los mismos:

\section{Sobre el conocimiento de traceability}

\subsubsection{Problemas}

\begin{itemize}

\item[-]    Existe poco consenso respecto a cuáles son las mejores técnicas y métodos para la aplicación de traceability, pocas anotaciones y documentación sobre las mejores prácticas, sumado a una falta de recursos que provean una buena base de conocimiento.

\item[-]    Las definiciones semánticas no coinciden y las terminologías son dispares o distintas, todo ésto crea barreras de comunicación.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}

\item[+] Crear una base de conocimiento en la que se vuelquen las mejores prácticas de traceability, una terminología estándar y mucha información adicional, como por ejemplo casos de estudio.

\end{itemize}

\section{Sobre la capacitación y la certificación}

\subsubsection{Problemas}

\begin{itemize}
\item[-]     Muy poca gente es competente en la definición de trazas y, por otro lado, existen disponibles pocos programas educativos.

\item[-]    Existen pocos programas de certificación, y de ellos, pocos incluyen componentes de traceability.

\item[-]   No hay definido un conjunto estándar de estrategias de traceability.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}
\item[+]     Identificar las áreas de conocimientos centrales y las habilidades y/o estrategias asociadas a traceability.

\item[+]   Desarrollar buenos componentes educativos para la puesta en práctica de traceability.

\item[+]   Desarrollar materiales pedagógicos efectivos para educar con énfasis en la importancia y administración de los costos-beneficios del uso de traceability.

\end{itemize}

\section{Sobre el soporte a la evolución}

\subsubsection{Problemas}

\begin{itemize}

\item[-]     La información precisa, coherente, completa y actualizada sobre traceability es fundamental para diversos ámbitos y aplicaciones. Sin embargo, las técnicas actuales de “recuperación de trazas” aún son realizadas de forma manual y por lo tanto son propensas a errores.

\item[-]    Para que los enlaces de traceability sean útiles, éstos deben reflejar la dependencia actual entre los artefactos. Dado que el costo y esfuerzo para mantenerlos durante la evolución del sistema es inmenso, a menudo los enlaces pasan a encontrarse en un estado erróneo o incorrecto.

 \item[-]   Las herramientas actuales de administración de requerimientos incluyen características como “suspect trace links” para ayudar a los analistas a administrar la evolución de los enlaces, pero en la mayoría de los proyectos complejos el número de “suspect trace links” se vuelve rápidamente excesivo, minimizando drásticamente la utilidad de tal característica.
 
\item[-]    Los enlaces de traceability tienen que evolucionar de forma sincrónica con los artefactos relacionados, sin embargo los sistemas actuales de gestión de cambios y la semántica de los enlaces no son lo suficientemente sofisticados como para apoyar esta evolución.

\item[-]    Los métodos para transformar y reusar los enlaces sincrónicamente con los productos de desarrollo en línea son inmaduros.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}

\item[+]     Desarrollar técnicas de “recuperación de trazas” para artefactos textuales que sean tan precisos como el proceso manual y a la vez mucho más efectivos en tiempo y costo.

\item[+]    Desarrollar la recuperación de trazas para que se encuentren integrados a los ``IDE''.

\item[+]    Desarrollar sistemas de administración de cambios que efectivamente soporten la evolución de los enlaces de trazas sobre múltiples tipos de artefactos.

\item[+]    Desarrollar técnicas que soporten traceability en todos los componentes de una línea de productos maximizando la reutilización y la disponibilidad de traceability entre diferentes versiones de los mismos.

\item[+]    Desarrollar técnicas para maximizar la reutilización de los enlaces de trazas cuando el código existente se reutiliza en un nuevo producto.

\end{itemize}

\section{Sobre la semántica de los enlaces}

\subsubsection{Problemas}

\begin{itemize}

\item[-]     Para efectivamente utilizar los enlaces de trazas y entender las relaciones por debajo de traceability, es necesario definir la semántica de los enlaces, sin embargo definir una formalidad para representar esta semántica no es una tarea fácil y puede llegar a ser acotada a un dominio específico, cosa que no es conveniente.

\item[-]    Es muy importante para la consistencia de traceability conocer y establecer la granularidad de los elementos a ser enlazados, pero no existe un modelo claro de costo-beneficio para determinar consistentemente cuál es la granularidad correcta (“trace granularity”).

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}

\item[+]     Definir meta-modelos para representar la información semántica de los enlaces de trazas y proveer ejemplos de instanciación para distintos dominios específicos.

\item[+]    Desarrollar técnicas y procesos para determinar la correcta granularidad de los enlaces de trazas en un proyecto.

\end{itemize}

\section{Sobre la escalabilidad}

\subsubsection{Problemas}

\begin{itemize}

\item[-]     Las técnicas corrientes de traceability no escalan adecuadamente en proyectos largos.

\item[-]    Las herramientas de visualización son esenciales para dar ayuda en la compresión y el uso de la gran cantidad de información de los enlaces de las trazas. Sin embargo, las técnicas de visualización actuales no escalan bien y no son efectivas al presentar información compleja porque carecen de características sofisticadas de filtrado, navegación, consultas, etc.

\item[-]    Muchos conjuntos de datos industriales son compuestos por largos e inestructurados documentos que son difíciles de enlazar mediante trazas.
\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}

\item[+]    Obtener conjuntos de datos de escala industrial desde varios dominios y usarlos para investigar la escalabilidad de las técnicas disponibles actualmente y, si es necesario, crear nuevas aproximaciones que escalen más eficientemente.

\item[+]    Desarrollar mecanismos visuales efectivos para soportar la navegación y consulta de un gran número de enlaces de traceability y sus artefactos asociados.

\item[+]    Desarrollar técnicas escalables para marcar las trazas tanto para conjunto de datos heterogéneos y/o grandes y débilmente estructurados.

\end{itemize}


\section{Sobre los factores humanos}

\subsubsection{Problemas}

\begin{itemize}

\item[-]     Los métodos automáticos de traceability producen enlaces de trazas candidatos; sin embargo, el proceso es inútil si el analista no es capaz de evaluarlos correctamente  para diferenciar los buenos de los malos, o si es incapaz de confiar en la completitud y precisión de los resultados.

\item[-]     Idealmente la tarea de encontrar las trazas debería ser invisible durante el proceso de desarrollo, desafortunadamente la generación de trazas y el uso es interrumpido por interacciones humanas porque en los ambientes de desarrollo actuales aún no es posible automatizar todo el proceso.

\item[-]     Los enlaces de trazas comunican artefactos semánticamente diferentes, a su vez estos artefactos son creados por diferentes personas y frecuentemente escritos en diferentes documentos. Como resultado, los usuarios de un lado de los enlaces de trazas no entienden bien los artefactos del otro lado de la relación.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}

\item[+]     Basado en el estudio del uso de herramientas de traceability, crear nuevas herramientas que reúnan las necesidades prácticas que vayan surgiendo.

\item[+]    Entender el impacto y las vulnerabilidades de la fallas humanas sobre el proceso de traceability y desarrollar técnicas para ayudar a los analistas a prevenir errores y minimizar el impacto de los mismos cuando ocurran.

\item[+]    Desarrollar técnicas para ayudar a los humanos a superar las barreras semánticas del proceso de desarrollo completo.

\end{itemize}

\section{Análisis de costo-beneficio}

\subsubsection{Problemas}

\begin{itemize}

\item[-]     En un escenario de traceability completo, los enlaces son creados entre artefactos en un nivel bajo de abstracción, ésto puede ser deseable para propósitos de comprensión, sin embargo este nivel tan bajo no es frecuentemente práctico y efectivo en costo.

\item[-]    Existe una carencia de un modelo de costo-beneficio para analizar entre las distintas necesidades de traceability sobre varios proyectos y para diferentes enlaces potenciales dentro de un proyecto.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}

\item[+]     Definir y desarrollar técnicas efectivas en costo para generar y mantener información de traceability.

\item[+]    Definir un modelo de costo práctico para generar y mantener los enlaces de trazas que tomen en consideración factores tales como el tamaño del proyecto, el tiempo, el esfuerzo y la calidad del sistema.

\item[+]   Definir un modelo de beneficios para usar enlaces de trazas que tomen en consideración factores como la crítica y la volatilidad, e incorpore el valor logrado mediante el uso de traceability.

\end{itemize}

\section{Sobre los métodos y las herramientas}

\subsubsection{Problemas}

\begin{itemize}

\item[-]     Los métodos de recuperación multimedia no son suficientemente sofisticados y soportados, y se ha realizado poco para incorporar tales técnicas multimedia en las herramientas de traceability.

\item[-]   Traceability automático es esencial; sin embargo, se hace difícil por la falta de consistencia entre los artefactos, y la imprecisión de los modelos.

\item[-]    Traceability implica todas las siguientes actividades: construcción o generación, evaluación, mantenimiento y el uso de los enlaces; sin embargo, no existe una sola herramienta que pueda cubrir todas estas tareas.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}

\item[+]     Desarrollar métodos efectivos para enlazar artefactos multimedia.

\item[+]    Construir métodos y herramientas con altos niveles de automatización para soportar el ciclo de vida entero, que incluya la construcción, la evaluación, el mantenimiento y el uso de los enlaces de trazas.

\item[+]    Desarrollar métodos para trazar requerimientos no funcionales.

\end{itemize}

\section{Sobre los procesos}

\subsubsection{Problemas}

\begin{itemize}

\item[-]     Traceability no es incluida frecuentemente como una parte integral del ciclo de vida del desarrollo.

\item[-]    Traceability automático puede proveer una alternativa efectiva en costo en comparación a la manual, pero la práctica ha mostrado que algunos conjuntos de datos son difíciles de enlazar usando métodos automáticos debido a las inconsistencias en terminología, los estándares, la carencia de estructuras, los formatos heterogéneos, etc.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}

\item[+]     Construir modelos de proceso que definan el ciclo de vida del marcado de trazas.

\item[+]   Desarrollar técnicas para evaluar la habilidad de un conjunto de datos dado para soportar los métodos automáticos de traceability.
 
\end{itemize}

\section{Sobre el cumplimiento}

\subsubsection{Problemas}

\begin{itemize}

\item[-]     Los estándares pueden ayudar a asegurar procesos consistentes y completos, aunque abundan los estándares, no está claro si los investigadores o profesionales están enterados de la existencia de los mismos.

\item[-]    La comunidad que engloba traceability son eruditos sobre técnicas y procesos de este tema, pero tienen poca influencia sobre los contenidos relacionados a traceability en los procesos estándar de ingeniería de software.

\item[-]    No es claro cómo se puede demostrar el cumplimiento de los estándares y regulaciones .

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}

\item[+]     Establecer un mecanismo de comunicación para hacer que la comunidad de expertos de traceability dictamine los estándares relacionados con la tecnología.

\item[+]    Lograr una presencia en la comunidad de estándares para influir y/o desarrollar estándares de traceability.

\item[+]    Como comunidad, desarrollar y promover escenarios válidos para probar que las herramientas, las técnicas y las metodologías de traceability cumplen con los estándares.

\end{itemize}


\section{Sobre las mediciones y los Benchmarks}

\subsubsection{Problemas}

\begin{itemize}

\item[-]     Los estudios empíricos son necesarios para demostrar la eficacia de los métodos de traceability y así, facilitar el trabajo colaborativo y evolutivo entre los investigadores y profesionales, sin embargo, hay una falta de diseños experimentales, metodologías y benchmarks comunes.

\item[-]    Las medidas, métodos y métricas propuestas actuales no han sido validadas a través de estudios o pruebas empíricas.

\item[-]    No existen o no se han realizado buenas pruebas o “benchmarks” de traceability y/o no son compatibles.

\item[-]    No existen pruebas estándares de comparación para aplicar sobre los métodos y técnicas desarrolladas de traceability.

\item[-]    La detección de errores en los enlaces de trazas es necesaria para determinar la eficacia del producto y el proceso, sin embargo los modelos de detección de errores actuales aún son primitivos e inválidos.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}

\item[+]     Definir procesos estándares para la realización de estudios empíricos durante la investigación de traceability.

\item[+]    Construir pruebas (benchmarks) para evaluar los métodos y las técnicas de traceability.

\item[+]    Definir medidas para evaluar la calidad de los enlaces de trazas tanto forma individual como la de un conjunto.

\item[+]    Desarrollar técnicas de evaluación de métodos y procesos de traceability.

\end{itemize}

\section{Sobre la transferencia de tecnología}

\subsubsection{Problemas}

\begin{itemize}

\item[-]     El objetivo de la investigación de traceability es la transferencia de soluciones eficaces para la industria, sin embargo en la realidad en la industria son reacios a probar técnicas nuevas donde la eficacia aún no fue demostrada.

\item[-]    La carencia de diálogo entre los dos grupos, investigadores y profesionales, limita la accesibilidad de los investigadores a un conjunto de datos reales para testear nuevas técnicas e inhibe la retroalimentación de la industria a los investigadores.

\item[-]    Los prototipos de Traceability son generalmente diseñados para mostrar demostraciones de conceptos, sin embargo no son suficientemente rigurosos para el campo de prueba de la industria.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}

\item[+]     Crear una infraestructura y un conjunto de métodos relacionados para organizar el proceso de transferencia de tecnología.

\item[+]    Identificar los casos de estudio exitosos y darle publicidad, para demostrar la efectividad de los costos de las técnicas de traceability en el ámbito industrial.

\item[+]    Identificar los usuarios de traceability y definir sus necesidades en términos de calidad, ciclo de vida, comunicación, etc.

\item[+]    Incorporar las herramientas de traceability que se encuentren a la vanguardia en los IDE estándares (tal como Eclipse) y las herramientas de administración de requerimientos industriales.

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%     Solución        %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Caminando hacia una solución}

A continuación se presenta una pequeña introducción a un conjunto de temas que se tuvieron en cuenta a la hora de definir el esquema de traceability propuesto que se presenta en el capítulo \ref{cap:Propuesta}.

\section{Generación de trazas}

Uno de los desafíos presentados en \cite{GrammelVoigt} trata sobre cuál de los dos enfoques de generación de trazas que existen durante una transformación, implícita o explícita, es conveniente utilizar. En la generación implícita la transformación provee un soporte integral de traceability, en cambio en la explícita, queda en manos del desarrollador codificar las reglas de traceability como un modelo más de salida.

A continuación se detallan las ventajas y desventajas de cada enfoque:

\subsection{Implícita}

\paragraph{Ventajas}

\begin{enumerate}

\item	La mayor ventaja de la generación de trazas implícita es que no es necesario ningún esfuerzo adicional para obtener los enlaces de trazas entre los modelos de entrada y salida, dado que son generados en paralelo automáticamente con el modelo actual de la transformación.

\end{enumerate}

\paragraph{Desventajas}

\begin{enumerate}

\item     El meta-modelo de traceability es fijo: como la mayoría de los enfoques de transformación tienen diferentes meta-modelos, lograr estandarizar entre estos diferentes enfoques es muy complejo.

\item    Poca flexibilidad para controlar los datos de traceability, ésto incluye:

\begin{enumerate}

\item         El tipo de información guardada: cuando se trazan todos los elementos del modelo referenciado, el número de enlaces puede volverse incomprensible y por lo tanto menos útil. También al presentarse un modelo de transformación grande y complejo puede acarrear un problema en lo que respecta a rendimiento.

\item        El nivel de granularidad de la información de traceability: (esto es por ejemplo realizar trazas solo a nivel de archivo o bajar a nivel del contenido del mismo) esta configuración de los enlaces varía de un escenario de traceability a otro.

\item       Contexto de la información: por ejemplo por necesidades de un cliente que presente motivos de seguridad, puede requerir que no toda la información de un modelo tiene permitido ser trazada.

\end{enumerate}

\end{enumerate}


\subsection{Explícita}

\paragraph{Ventajas}

\begin{enumerate}

\item Es posible lidiar con traceability como un modelo regular de salida de la transformación e incorporar reglas de transformación adicionales para generarlo. La elección del meta-modelo es entonces completa del programador y no depende del motor de transformaciones. Por lo tanto, la granulación de los enlaces es adaptable.

\end{enumerate}

\paragraph{Desventajas}

\begin{enumerate}

\item     Se requiere un esfuerzo adicional para agregar reglas de transformación específicas para traceability, que pueden en consecuencia contaminar la implementación.

\item    Como esta tarea es por lo general manual, es propensa a errores y consume mucho tiempo, más aun si pensamos que esta tarea se tiene que repetir para cada transformación que se realice.

\end{enumerate}

\section{Tipos de enlaces}

Otro de los desafíos refiere a la semántica de los enlaces, es necesario frecuentemente distinguir entre los distintos tipos de enlaces que se pueden presentar. Por ejemplo un enlace entre un requerimiento textual y un elemento de modelo, tiene una semántica distinta que una relación de refinamiento dentro de un modelo. 

Los tipos de enlaces requeridos por lo general son fuertemente dependientes al proyecto. Por lo cual definir fijamente los tipos de enlaces semánticos tiene la consecuencia de menor flexibilidad para los enlaces que desee trazar el usuario, los cuales serán definidos por las necesidades del proyecto o la compañía. 

Es importante remarcar que la determinación de la semántica de un enlace es guiada por la razón del usuario sobre qué quiere realizar o representar con dicho enlace. No predefinir la semántica correctamente de un enlace puede resultar en fallas de razonamientos.

\section{Estrategias de almacenamiento}

Según \cite{DrivalosPaigeFernandesKolovos} hay dos tipos principales de estrategias para almacenar y administrar la información de traceability. En la primera, la información de traceability se encuentra embebida en los modelos a los que ella refiere. En cambio en la segunda, dicha información se encuentra almacenada de forma separada de los modelos:

\subsection{Almacenamiento de enlaces Intra-Modelo}

Como ya se dijo, bajo esta estrategia la información de traceability es almacenada dentro de los artefactos a los que refiere, esto puede ser mediante elementos del modelo o mediante atributos de los elementos del modelo (como etiquetas o propiedades). 

Es una estrategia sencilla y amigable, pero puede ser muy problemática por varias razones. Si los enlaces son dirigidos y almacenados solamente en el modelo origen, éstos no son visibles en el modelo destino, a la inversa (almacenados en el destino) nos encontramos con el mismo problema pero en el origen. Por otro lado, si la información de traceability es almacenada en ambos modelos, entonces nos encontramos con el problema de que dicha información se mantenga consistente por cada vez que se realice un cambio.

A todo lo anterior se suma el problema de la polución que se genera en el modelo con la información de traceability que es ajena a su contexto o fin original, dicha polución puede lograr que el modelo se vuelva muy difícil de comprender y mantener. 

Por otro lado, en un entorno MDE es común que los modelos tengan sus propias representaciones y semánticas, lo cual puede volver más complejo diferenciar la información de traceability de los objetos que representan el modelo del dominio. 

Como resultado a los inconvenientes anteriores, el análisis automatizado de la información de traceability se hace muy difícil. Los enfoques principales que hacen uso de esta estrategia utilizan construcciones  de lenguajes específicas, por ejemplo determinados tipos de enlaces de traceability están representados en los diagramas UML mediante el uso de las estereotipos como <<refines>>.

\subsection{Almacenamiento externo de los enlaces}

En esta estrategia la información de traceability se encuentra almacenada de forma separada a los modelos a los que refiere, esto es en un modelo aparte. Esta propuesta tiene dos claras ventajas, la primera es que los modelos origen y destino se mantienen totalmente limpios, con lo cual la polución nombrada en el almacenamiento intra-modelo no sucede. Y la segunda, dado que el modelo en donde se almacena los traceability links se encuentra definido por un meta-modelo con una clara semántica, logra que el proceso de análisis de la información sea mucho más fácil que en la otra estrategia.

Un requisito previo para el almacenamiento externo de los enlaces de traceability, es que los diferentes elementos del modelo tengan identificadores únicos, de modo que las trazas que los relacionan se pueden resolver inequívocamente. Un ejemplo es el mecanismo propuesto por MetaObject Facility (MOF) y por Eclipse Modeling Framework (EMF) en la forma de un identificador xmi.id .

\section{Meta-modelos}

Los modelos que determinan los enlaces de traceability se encuentran definidos cada uno por un meta-modelo, éste puede ser clasificado como un “meta-modelo de traceability de propósito general” o un “meta-modelo de traceability de caso específico”.

\subsection{Meta-modelo de propósito general}

En este caso, nos encontramos con un meta-modelo genérico que permite la captura de las relaciones entre cualquier tipo de elementos de modelo. En este meta-modelo, un enlace de traceability se puede conectar con cualquier número de elementos, de cualquier tipo y de cualquier modelo. Las principales ventajas de este tipo de meta-modelo de propósito general son la simplicidad y la uniformidad (dado que todos los modelos conforman el mismo meta-modelo) con lo cual se mejora la interoperabilidad de las herramientas con capacidades de importar, exportar y gestionar traceability en un formato común. 

Por otro lado, como el meta-modelo de propósito general no capta casos específicos de enlaces de trazas fuertemente tipados, o sea con semántica y restricciones definidas rigurosamente, se abre la puerta a establecimientos de enlaces ilegítimos. Como por ejemplo en el caso que se quiera representar trazas entre un diagrama de clases y un modelo de base de datos relacional, sabemos que existen vínculos entre las clases del primer modelo y las tablas del segundo, un meta-modelo de traceability genérico permite el establecimiento de enlaces ilegítimos tales como una clase relacionada con una columna. 

La provisión de mecanismos de extensión junto con el meta-modelo de propósito general es un método de uso frecuente para permitir un mejor apoyo para el caso de los requisitos específicos. Sin embargo, todavía carecen de la eficacia de los meta-modelos de casos específicos para capturar estos tipos de casos que requieren tal legitimidad entre la información y su semántica.

\subsection{Meta-modelo de caso específico}

En este caso, para cada escenario de traceability se define un meta-modelo de traceability específico. Este meta-modelo de traceability captura traceability links fuertemente tipados de caso específico con una semántica bien definida, que pueden o no incluir restricciones de corrección. Debido a su naturaleza de tipado fuerte y las restricciones asociadas, restringe a los usuarios y herramientas para que solo puedan establecer traceability links legítimos. Por otro lado, un meta-modelo de traceability para cada caso específico requiere mucho esfuerzo en su construcción, así como herramientas que soporten diferentes meta-modelos de traceability.
Para ser fuertemente tipado el meta-modelo de traceability necesita referir explícitamente a los tipos de elementos definidos en otros meta-modelos. Por ejemplo, considereremos que es necesario definir un meta-modelo de traceability que permita el establecimiento de traceability links entre instancias de A (del meta-modelo MMa) y las de B (a partir de MMb), pero no entre dos instancias de A o dos de B. Para capturar tal meta-modelo, la tecnología de modelado que se use no debe tomar cada meta-modelo como un espacio cerrado, sino que debe permitir referencias inter-meta-modelo. Un ejemplo de tecnología que soporta referencias inter-meta-modelo es el Eclipse Modeling Framework (EMF).
A pesar de que un meta-modelo capturado utilizando una tecnología que permita referencias inter-meta-modelo puede confiar tipos seguros, encontramos frecuentemente otras restricciones que necesitan especificarse y que el meta-modelo de traceability no puede capturarlas. Por ejemplo tomando como referencia el ejemplo anterior, podríamos querer que cada instancia A de MMa sólo se puede vincular a no más de una instancia B de MMb. Para especificar tales restricciones, se requiere un lenguaje de especificación de restricciones que pueda expresar restricciones que abarquen elementos que pertenezcan a modelos definidos por diferentes meta-modelos. En la actualidad el Object Constraint Language (OCL) carece de esta capacidad, ya que no proporciona las construcciones para la expresión de restricciones que atraviese modelos (cross-model). Ejemplos de lenguajes de restricción que soportan el establecimiento con tales restricciones incluyen el Epsilon Validation Language (EVL) y el XLinkit toolkit.
La combinación de un meta-modelo de traceability fuertemente tipado conjunto con la verificación de restricciones inter-modelo restringe a los usuarios y a las herramientas a establecer y mantener sólo traceability links con sentido, que pueden ser automáticamente validadas para descubrir posibles omisiones e inconsistencias. Estas cuestiones pueden surgir, ya sea durante el establecimiento de los traceability links o más tarde en el ciclo de vida de los modelos entre los que los traceability links ya han sido establecidos.

\section{Una clasificación genérica de traceability}

Conforme un proyecto de desarrollo crece, la administración de la información de traceability que se va generando se vuelve extramadamente compleja, una jerarquía de clasificación de esta información de traceability resulta esencial para poder entenderla y administrarla mejor. En \cite{PaigeOlsenKolovosZschalerPower} se encuentra una propuesta de clasificación de traceability conjunto con la descripción del proceso usado para su obtención al que llamaron ``Traceability Elicitation and Analysis Process'' (TEAP).

Esta clasificación comienza con una simple clasificación o meta-modelo de traceability inicial, luego de forma incremental e iterativa se refina la clasificación siguiendo las siguientes tareas: obtención, análisis y clasificación. En la obtención se identifica un trace link y sus relaciones. En el análisis, se abstraen las principales características del trace link obtenido identificando restricciones, relaciones y generalizaciones. Por último, se construye la clasificación.

El meta-modelo inicial propuesto se muestra en el dibujo \ref{fig:ClasifInicial} en el que se encuentran los conceptos fundamentales de artefacts, trace links y operations. Artefact refiere tanto a artefactos MDE (ejemplo modelos específicos de dominio) como a no MDE (ejemplo hojas de cálculo), Operation encierra las operaciones bien manuales como automáticas que determina qué información de traceability debe almacenarse, y por último Trace Link engloba la clasificación que comienza con la idea de traceability implícita (Implicit Link) y explícita (Explicit Link). En este contexto, traceability implícita refiere a trace links que son creados y manipulados por la aplicación de operaciones MDE, en cambio explícita refiere a trace links que se encuentran ya concretamente representados en los modelos.


\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.75]{./img/ExplicitImplicitTraceLinkClassification}
\caption{Clasificación de traceability inicial}
\label{fig:ClasifInicial}
\end{figure}

\subsection{Clasificación de trace links implícita}

En esta jerarquía que se muestra en el dibujo \ref{fig:LinksImplicitos} se presentan un conjunto de operaciones de MDE principales: consulta (Query Link), transformación (M2M Link), transformación modelo a texto (M2T Link), composición (Composition Link), actualización (Update Link), creación (Creation Link), eliminación (Delete Link), entre otras.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.55]{./img/ImplicitTraceLinks}
\caption{Jerarquía de links implícitos}
\label{fig:LinksImplicitos}
\end{figure}

\subsection{Clasificación de trace links explícita}

En esta jerarquía se clasifican los trace links explícitos, por ejemplo una dependencia UML es uno de ellos. En principio se identifican dos clases básicas: links modelo-modelo (ejemplo dependencias UML) y links modelo-artefacto (entre un modelo y un documento de texto que dicta un requerimiento), que en el dibujo \ref{fig:LinksExplicitos} aparecen como Model-Model Link y Model-Artefact Link.

Model-Model Link es dividido en links estáticos (Static Link) y dinámicos (Dynamic Link). Los primeros representan relaciones estructurales que no cambian con el tiempo, los segundos representan información de los modelos que pueden variar a través del tiempo. Ejemplos de links estáticos, links consistentes (Consistent-With) donde dos modelos deben mantenerse de acuerdo o consistentes entre si, y links de dependencias (Dependency) donde la estructura y/o la semántica de un modelo depende de otro. Los links de dependencia pueden ser divididos: links de relación de subtipo (Is-A), links de referencias, links de subconjuntos, de importación y exportación, de uso, de refinamiento (Refines), etcétera. Ejemplos de links dinámicos incluyen links de llamadas (Calls) donde un modelo hace uso de métodos provisto por otro, links de notificación (Notifies) donde es necesario almacenar información que puede ser manejada automáticamente. También relaciones en tiempo de diseño como links de generación o construcción (Generates) que indica qué información de un modelo es usada para producir o deducir otro, y relaciones de sincronización (Synchronized With) donde el comportamiento de un conjunto de modelos es sincronizado.

El alcance de Model-Artefact Link es muy amplio, es esta clasificación solo se resumen un subconjunto de ejemplos, entre ellos: la relación satisface (Satisfies) que indican que propiedad o requerimiento de un artefacto es satisfecha por un modelo; links de asignación (Allocated-To) usados cuando la información de un artefacto no modelo es asignada a un modelo específico que la representa; la relación de realización (Performs) que indica que tarea descripta por un artefacto es llevada a cabo por el modelo; las relaciones explica y respalda (Explains y Supports respectivamente) que dictan qué modelo es explicado/respaldado por un artefacto no modelo.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.51]{./img/ExplicitTraceLinks}
\caption{Jerarquía de links explícitos}
\label{fig:LinksExplicitos}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%     Propuesta      %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Esquema propuesto}\label{cap:Propuesta}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%     tecnologías     %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Descripción de tecnologías}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Trabajos relacionados %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Trabajos relacionados}

\section{Un motor de traceability de transformación de modelos en Ingeniería de Software}

En \cite{AmarLeblancCoulette} se describe un motor de traceability al que llamaron ETraceTool, que funciona como un plug-in de Eclipse programado mediante el paradigma orientado a aspectos con el fin de mantener aislada la generación de las trazas del código de la transformación. El mismo trabaja sobre transformaciones escritas en Java usando la API EMF \cite{EMF}. A continuación se listan sus principales características:

\begin{itemize}
\item     El código de generación de trazas no es intrusivo en el código de la transformación;
\item    La generación de trazas es activada explícitamente por el diseñador de la transformación;
\item    Los modelos de las trazas se encuentran aisladas o aparte de los modelos origen y destino que forman parte de la transformación;
\item    Los modelos de las trazas pueden ser usados a diferentes niveles de granularidad.
\end{itemize}

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.5]{./img/ETraceTool_Arquitectura}
\caption{Arquitectura de la herramienta ETraceTool}
\label{fig:ArqETraceTool}
\end{figure}

La arquitectura se presenta en el dibujo \ref{fig:ArqETraceTool} y se explica de la siguiente manera, durante la transformación el plug-in captura un conjunto de eventos previamente identificados y clasificados gracias a la programación orientada a aspectos, luego el Aspect Tracer genera un modelo de trazas que conforma o ajusta al meta-modelo de trazas anidado que se muestra en el dibujo \ref{fig:ETraceToolMeta-modelo}. Al final, el modelo de trazas generado puede ser serializado en un archivo XMI o transformado a cualquier otro lenguaje mediante una transformación modelo-texto.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.6]{./img/NestedTraceMetamodel}
\caption{Meta-modelo de trazas anidado}
\label{fig:ETraceToolMeta-modelo}
\end{figure}

El fundamento para el diseño del meta-modelo de trazas anidado propuesto es dado el caso en el que se presente una operación de transformación que llama o hace uso de otra transformación. En este caso el enlace compuesto permite separar las operaciones de bajo nivel (creación, eliminación, etc) de las operaciones de alto nivel (como una operación de refactorización).

\section{Un Framework  de Traceability dirigido por modelos para el desarrollo de Software Product Line (SPL)}

El framework presentado en \cite{SousaKuleszaRummlerAnquetilMitschkeMoreiraAmaralAraujo}  provee una plataforma abierta y flexible para crear enlaces de trazas entre distintos artefactos del desarrollo SPL, aunque dado que el diseño del framework es genérico, éste también puede aplicarse o usarse fuera del desarrollo SPL. El mismo ha sido diseñado e implementado basado en el uso de técnicas dirigidas por modelos. El meta-modelo de traceability descripto en el dibujo \ref{fig:SPLMeta-modelo} permite definir distintos tipos de enlaces de trazas entre los artefactos.

Las principales funcionalidades ofrecidas por el framework son las siguientes:

\begin{enumerate}
\item     Creación y mantenimiento de los enlaces de trazas de artefactos existentes (modelos UML, código fuente, etc);
\item    Almacenamiento de los enlaces de trazas mediante el uso de un repositorio;
\item    Búsqueda de enlaces de trazas específicos usando consultas de trazas predefinidas o personalizadas;
\item    Visualización flexible de los resultados de las consultas de trazas por medio de diferentes tipos de vistas, como vista de árbol, grafo, tabla, etc.
\end{enumerate}

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.6]{./img/Traceability_Metamodel}
\caption{Meta-modelo de traceability}
\label{fig:SPLMeta-modelo}
\end{figure}

\subsection{Meta-modelo de traceability}

Los elementos principales del meta-modelo son los siguientes:

\begin{itemize}
\item     Un TraceableArtefact representa un artefacto que juega un rol en el ciclo del desarrollo. La granularidad del artefacto es arbitraria, puede ser un requerimiento, un diagrama UML, un elemento de dicho diagrama, una clase o un método de dicha clase. Dicho artefacto es identificado mediante resourceId.
\item    Un TraceLink es la abstracción de una transición de un artefacto a otro.
\item    Cada TraceableArtefact tiene asignada una instancia de TraceableArtefactType, éstos pueden ser agrupados jerárquicamente.
 \item   Análogo a los tipos de los artefactos los TraceLinks también tienen un tipo, TraceLinkType, dado que la semántica de una relación entre dos artefactos puede variar.
\item    Información adicional de artefactos y enlaces puede ser modelada mediante el contexto representado por TraceContext.
\item    Las restricciones sobre el conjunto válido de artefactos sobre los cuales los tipos de enlaces son válidos es modelado mediante los elementos ScopeArea y Scope.
\end{itemize}

\subsection{Arquitectura}

Como se muestra en el dibujo \ref{fig:SPLArquitectura}, la arquitectura ha sido definida en término de cuatro módulos principales. Cada uno de los cuales implementa una de las funcionalidades principales del framework antes nombradas como se detalla a continuación:

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.55]{./img/ArquitecturaTraceabilityFramework}
\caption{Arquitectura del Framework de Traceability}
\label{fig:SPLArquitectura}
\end{figure}

\begin{enumerate}
\item    Trace Register: este módulo provee mecanismos para crear y mantener (actualizar, eliminar y buscar) enlaces de trazas;
\item     Trace Storage: define los mecanismos de almacenamiento para persistir los enlaces de trazas;
\item     Trace Query: éste permite crear y ejecutar consultas para buscar enlaces de trazas específicos previamente almacenados;
\item     Trace View: usado específicamente para la representación visual de los enlaces de trazas entre los artefactos de software resultados de una consulta realizada.
\end{enumerate}


\section{Integración de herramientas Case}

En \cite{KlarRoseSchurr} se presenta el problema real que sufre cualquier proceso de desarrollo actual, en el que en su conjunto de actividades o pasos que lo conforman se van generando una variedad muy amplia de artefactos de software (documentos de textos, hojas de cálculo, resultado de pruebas, modelos, gráficos, etc) que aunque en esencia éstos se relacionan lógicamente, al ser creados y manipulados por herramientas muy distintas que no fueron pensadas para interactuar (editores de textos, editores de modelo UML, etc), estas relaciones entre dichos artefactos se pierden o mejor dicho no existen en la práctica. En otras palabras, presenta el problema de la imposibilidad de traceability entre la mayoría de las herramientas CASE actuales. Como solución a este problema, propusieron un ambiente de integración para estas herramientas  al que llamaron TiE - Tool Integration Environment, el mismo basa su integración por medio de la creación de traceability links entre los artefactos que pertenecen a las distintas herramientas.

\section{Framework de extracción de datos de traceability genérico}

En \cite{GrammelKastenholz} proponen un framework genérico de traceability que toma una transformación de modelo y aumenta arbitrariamente su funcionalidad con un mecanismo de traceability. En el dibujo \ref{fig:GenericoArquitectura} se muestra un panorama de alto nivel de la arquitectura propuesta. Se basa en una interfase genérica que provee un punto de conexión para cualquier motor de transformación de modelos, mediante una API que se ofrece al ingeniero que conecta su motor de transformación con el motor de traceability (oAW connector, QVT connector). Como resultado el motor de transformación incluye la funcionalidad de traceability. El modelo de datos que usa el framework es el lenguaje específico de dominio para traceability que llaman Trace-DSL.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.7]{./img/GenericTraceFrame_Arquitectura}
\caption{Resumen de la arquitectura del Framework Genérico de Traceability}
\label{fig:GenericoArquitectura}
\end{figure}


Trace-DSL que se detalla en el dibujo \ref{fig:DSLTrace}, incluye como elemento raíz TraceModel. Un Artefact representa cualquier producto traceable generado en el proceso de desarrollo, como un requerimiento o una clase o un componente como un método dentro de una clase, cualquier artefacto es identificado por un identificador único universal (UUID). Un TraceLink es una abstracción de una transición de un artefacto a otro dirigida por la relación desde-hacia entre artefactos origen y destino. TraceLink puede ser de uno de las siguientes cuatro instancias: CreateTraceLink, QueryTraceLink, UpdateTraceLink y DeleteTraceLink.


\begin{figure}[hbtp]
\centering
\includegraphics[scale=.8]{./img/Trace-DSL}
\caption{Lenguaje específico de dominio para traceability}
\label{fig:DSLTrace}
\end{figure}

Para asignar tipos a los artefactos y a los enlaces se usa el concepto de faceta, donde Trace-DSL asigna un conjunto de facetas (Facet) a cada uno de los mismos. Un ejemplo de faceta se da en el dibujo \ref{fig:FacetaCodigoFuente}. Además de lograr una solución simple al tipado de artefactos y enlaces, se obtiene un mecanismo fácilmente extensible al contexto donde se necesite aplicar traceability.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.72]{./img/Faceta}
\caption{Faceta para traceability de código fuente}
\label{fig:FacetaCodigoFuente}
\end{figure}

La configuración necesaria para hacer uso del framework implica:

\begin{enumerate}
\item    Seleccionar las facetas requeridas para el escenario
\item    Configurar la granularidad (Granularity) y el alcance (Scope)
\end{enumerate}

La configuración de la granularidad consiste en la especificación de qué tipos (definidos por las facetas) de artefactos y enlaces serán trazados para un escenario de de traceability particular. En cambio la configuración del alcance implica restringir los datos de traceability a tener una combinación específica de valores. En otras palabras la primera solo chequea la existencia de facetas, mientras que la segunda adicionalmente examina las propiedades especificas de las facetas. Por ejemplo en el caso de TextFileFacet, puede ser necesario trazar solo archivos de textos con cierto nombre.

\section{Traceability local y global}

En la propuesta presentada en \cite{GlitiaEtienDumoulin} usan la idea de separación del proceso de traceability en los siguientes niveles, traceability en lo pequeño y traceability en lo grande refiriéndose a los mismos como traceability local y traceability global respectivamente.

\subsection{Meta-modelo de Traceability Local}

Este meta-modelo toma las trazas de la entrada y la salida de una única transformación. El meta-modelo está basado en el meta-modelo de trazas presentado en \cite{Jouault} y se muestra en el dibujo \ref{fig:LocalTraceMetamodel}.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.55]{./img/LocalTraceMetamodel}
\caption{Meta-modelo de Trazas Local}
\label{fig:LocalTraceMetamodel}
\end{figure}

El meta-modelo de trazas local contiene dos conceptos principales Link y ElementRef en donde se expresa que uno o más elementos orígenes son enlazados a uno o más elementos objetivos. ElementRef es una clase abstracta que representa elementos que pueden ser traceados: instancias de clases o valores de propiedades. Los valores de las propiedades son traceados usando PrimitivePropertyRef el cual apunta a la instancia contenedora de la propiedad y tiene el nombre de la misma. Este tratamiento especial para los tipos primitivos de Java se debe a que no existen instancias de ellos en el modelo. Por otro lado las propiedades que son tipadas mediante una clase normal, son traceadas mediante ClassRef.

Para almacenar la información sobre las reglas de transformación aplicadas así como el caso particular de las cajas negras, se hace uso de los conceptos RuleRef y BlackBoxRef. Ambos casos pueden dar como resultado varios enlaces, por eso la relación uno a varios entre RuleRef y Link. RuleRef y BlackBoxRef son opcionales, en el caso de la primera sólo se usa para el caso de realizar una depuración de las transformaciones, y la segunda si nos encontramos con ciertas partes del sistema que no pueden ser vista su implementación.

ElementRef tiene una referencia al objeto real de los modelos origen y destinos. Como estos modelos están implementados mediante EMF, la referencia EMFObject es un EObject del meta-modelo Ecore. La clase LocalTraces representa la raiz del modelo de trazas local y tiene un RuleContainer que se usa como contenedor de las reglas y dos ElementContainer usados para agrupar los ElementRef origen y destino respectivamente. Separar los elemento orígenes y destinos permite reducir los costos de búsquedas de elementos de entrada o salida.

\subsection{Meta-modelo de Traceability Global}

Este meta-modelo enlaza trazas locales de acuerdo a la cadena de transformación. Un modelo de trazas global es el punto de entrada principal en el cual todas los modelos de trazas locales se encuentran, y describe qué modelo origen/objetivo de una transformación es el modelo objetivo/origen de la siguiente/previa transformación. El dibujo \ref{fig:GlobalTraceMetamodel} muestra el meta-modelo.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.6]{./img/GlobalTraceMetamodel}
\caption{Meta-modelo de Trazas Global}
\label{fig:GlobalTraceMetamodel}
\end{figure}

Este meta-modelo engloba todas las trazas locales y los modelos de una cadena de transformación y la forma en que éstos se encuentran enlazados mediante TraceModel y LocalModel. Los modelos pueden ser compartidos entre distintas transformaciones, es decir uno puede ser producto de una transformación y también ser consumido por otra transformación.

Introducir este nivel global de trazas permite la navegación entre los modelos transformados y sus modelos de trazas locales, dando una mejor separación de la compleja información de traceability lo que permite una mejor flexibilidad para la creación de las trazas y la explotación o uso de las mismas. No utilizar esta idea de trazas globales podría tener como consecuencia el colapso de todos las trazas en un único modelo de trazas para toda la cadena de transformación, más difícil de crear y consultar.

\subsection{¿Cómo trabaja el framework?}

Una de los principales objetivos de recolectar las trazas es dar luego la posibilidad a un usuario de inspeccionarlas realizando distintas consultas, una puede ser por ejemplo obtener los elementos relacionados a uno seleccionado.

Este meta-modelo permite desde el modelo de trazas global navegar hacia los modelos de trazas locales y/o hacia a los modelos envueltos en cada una de las transformaciones. También desde el modelo de trazas local se puede navegar entre los elementos del modelo parte de la transformación.

En el dibujo \ref{fig:EjemploLocalGlobalMetamodel} se muestra un ejemplo de un modelo de trazas locales y globales producto de una cadena de transformación. En el ejemplo se representan los enlaces (Link) entre los elementos sin tener en cuenta las instancias de RuleRef para no sobrecargarlo.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.45]{./img/EjemploLocalGlobalMetamodel}
\caption{Ejemplo de un modelo de trazas local y global}
\label{fig:EjemploLocalGlobalMetamodel}
\end{figure}


\backmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%     Conclusión      %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusión}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%     Glosario        %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Glosario}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%     Bibliografía    %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{99}


\bibitem{IEEE} IEEE Standard Glossary of Software Engineering Terminology. Number Std 610.12-1990, IEEE (1990).

\bibitem{BrcinaRiebisch} R. Brcina and M. Riebisch: Defining a Traceability Link Semantics for Design Decision Support. In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\bibitem{GrammelVoigt} B. Grammel and K. Voigt: Foundations for a Generic Traceability Framework in Model-Driven Software Engineering. In: ECMDA Traceability Workshop (ECMDA-TW) 2009 Proceedings.

\bibitem{Glossary} Glossary of Center of  Excellence for Software Traceability (CoEST) \url{http://www.coest.org/index.php/traceability/glossary}.

\bibitem{Excellence} Center of Excellence for Traceability - Problem Statements and Grand Challenges. In: Center of Excellence of Traceability Technical Report (COET-GCT-06-01-0.9) September 10, 2006.

\bibitem{GotelFinkelstein} Gotel, O.C.Z., Finkelstein, A.C.W., “An Analysis of the Requirements Traceability Problem”, International Conference on Requirements Engineering, ICRE’94, Los Alamitos, California, Abril, 1994, pp 94-101.

\bibitem{DrivalosPaigeFernandesKolovos} N. Drivalos, R. F. Paige, K. J. Fernandes, D. S. Kolovos: Towards Rigorously Defined Model-to-Model Traceability. In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\bibitem{GlitiaEtienDumoulin} F. Glitia, A. Etien and C. Dumoulin: Fine Grained Traceability for an MDE Approach of Embedded System Conception. In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\bibitem{Jouault} F. Jouault: Loosely Coupled Traceability for ATL, In: Proceedings of the European Conference on MDA Traceability Workshop, Nurnberg, Germany (2005).

\bibitem{PaigeOlsenKolovosZschalerPower} R. Paige, G. Olsen, D. Kolovos, S. Zschaler, C. Power: Building Model-Driven Engineering Traceability Classifications, In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\bibitem{KlarRoseSchurr} F. Klar, S. Rose, A. Schurr: TiE - A Tool Integration Environment,  In: ECMDA Traceability Workshop (ECMDA-TW) 2009 Proceedings.

\bibitem{AbidBotterweck} S. B. Abid, G. Botterweck: Resolving Product Derivation Tasks using Traceability in Software Product Lines, en: ECMDA Traceability Workshop (ECMDA-TW) 2009 Proceedings.

\bibitem{GrammelKastenholz} B. Grammel, S. Kastenholz: A Generic Traceability Framework for Facet-based Traceability Data Extraction in Model-driven Software Development, en: Proceedings of the 6\grad ECMFA Traceability Workshop (ECMFA-TW), 15 de junio de 2010, Paris, Francia.

\bibitem{AmarLeblancCoulette} B. Amar, H. Leblanc, B. Coulette: A Traceability Engine Dedicated to Model Transformation for Software Engineering. In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\bibitem{EMF} Eclipse Modeling Framework Project (EMF) \url{http://www.eclipse.org/modeling/emf/}.

\bibitem{SousaKuleszaRummlerAnquetilMitschkeMoreiraAmaralAraujo} A. Sousa, U. Kulesza, A. Rummler, N. Anquetil, R. Mitschke, A. Moreira, V. Amaral, J. Araújo: A Model-Driven Traceability Framework to Software Product Line Development. In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\end{thebibliography}


\end{document}
