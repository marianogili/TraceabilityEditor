\documentclass[a4paper,12pt,oneside,spanish]{book}
\usepackage[utf8]{inputenc}
\usepackage{babel,amsmath,graphicx,enumitem,amsfonts,appendix,listingsutf8,xcolor,framed,parskip,fancyhdr}
\usepackage[colorlinks=true,linkcolor=black]{hyperref}
\usepackage[acronym,toc,xindy]{glossaries}
\usepackage[undotted]{minitoc}
\usepackage{pdfpages}

\addtolength{\textwidth}{.5cm}
\addtolength{\textheight}{1cm}

\newcommand{\grad}{\hspace{-2mm}$\phantom{a}^{\circ}$}

\renewcommand{\appendixname}{Anexos}
\renewcommand{\appendixtocname}{Anexos}
\renewcommand{\appendixpagename}{Anexos}

%\renewcommand{\mtctitle}{}

% Sangría
\setlength{\parindent}{1.5em}

% encabezados
\lhead[]{\leftmark}
\chead[]{}
\rhead[]{}
\renewcommand{\headrulewidth}{0.5pt}

% pie de pagina
\lfoot[]{}
\cfoot[]{}
\rfoot[]{\thepage}
\renewcommand{\footrulewidth}{0.5pt}

% primera pagina de un capitulo
\fancypagestyle{plain}{
\fancyhead[L]{Tesina de grado: Mecanismos de rastreo en MDD}
\fancyhead[C]{}
\fancyhead[R]{Mariano Gabriel Gili}
\fancyfoot[L]{}
\fancyfoot[C]{}
\fancyfoot[R]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
}

\pagestyle{fancy}


\author{Mariano Gabriel Gili}
\title{Tesis}
\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Glosario            %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeglossaries

\newglossaryentry{mde}{
	name={MDE - Ingeniería de Software Dirigida por Modelos},
	text={Ingeniería de Software Dirigida por Modelos (\textit{MDE} de Model-Driven Engineering)},
	symbol={MDE},
	description={en inglés Model-Driven Engineering (MDE), es un paradigma de ingeniería de software en el cual los modelos juegan el rol principal en todas las actividades del ciclo de vida de la misma}
}

\newglossaryentry{mda}{
	name={MDA - Arquitectura Dirigida por Modelos}, 
	text={Arquitectura Dirigida por Modelos (\textit{MDA} de Model-Driven Architecture)},
	symbol={MDA},
	description={en inglés Model-Driven Architecture (MDA), es una visión o propuesta particular definida por el \glssymbol{omg} de \glssymbol{mdd} que se basa en el uso de estándares de \glssymbol{omg}}
}

\newglossaryentry{omg}{
	name={OMG - Object Management Group}, 
	text={Object Management Group (\textit{OMG})},
	symbol={OMG},
	description={Consorcio internacional de la industrial informática sin fines de lucro y de membresía abierta responsable de la definición de varios estándares de modelado como \gls{uml}, \gls{mof} y \glssymbol{mda}}
}

\newglossaryentry{mdd}{
	name={MDD - Desarrollo Dirigido por Modelos}, 
	text={Desarrollo Dirigido por Modelos (\textit{MDD} de Model-Driven Development)},
	symbol={MDD},
	description={en inglés Model-Driven Development (MDD), es un paradigma de desarrollo de software que utiliza modelos como artefactos principales del proceso de desarrollo. Por lo general, la implementación se genera o deriva automáticamente a partir de los modelos}
}

\newglossaryentry{gef}{
	name={GEF - Graphical Editing Framework}, 
	text={Graphical Editing Framework (\textit{GEF})},
	symbol={GEF},
	description={Es un framework Eclipse para el desarrollo de editores gráficos y vistas del Eclipse Workbench UI}
}

\newglossaryentry{jdt}{
	name={JDT - Java Development Tool}, 
	text={Java Development Tool (\textit{JDT})},
	symbol={JDT},
	description={Es un proyecto que proporciona herramientas tipo plug-ins de Eclipse que asisten en el desarrollo de aplicaciones Java. Incluye la creación de proyectos Java, una perspectiva para el Workbench Eclipse, así como también un conjunto de vistas, editores, asistentes, constructores y herramientas de refactorización y fusionado de código. Estas herramientas transforman a Eclipse en un \gls{ide}}
}

\newglossaryentry{mof}{
	name={MOF - MetaObject Facility}, 
	text={MetaObject Facility (\textit{MOF})},
	symbol={MOF},
	description={es un lenguaje estándar del \glssymbol{omg} para \glssymbol{mde}, en particular es un meta-meta lenguaje que permite definir meta-modelos en la capa M2, como por ejemplo el meta-modelo \gls{uml} que describe al lenguaje \gls{uml}. Como su nombre lo indica, MOF se basa en el paradigma Orientado a Objetos}
}

\newglossaryentry{ocl}{
	name={OCL - Object Constraint Language}, 
	text={Lenguaje de Restricciones para Objetos (\textit{OCL} de Object Constraint Language)},
	symbol={OCL},
	description={es un lenguaje declarativo para describir reglas
que se aplican a meta-modelos \glssymbol{mof} y a los modelos \gls{uml}. Fue desarrollado por IBM y en la actualidad es parte del estándar \gls{uml}. OCL es un lenguaje de texto que permite definir restricciones y consultas sobre expresiones de objetos de cualquier modelo o meta-modelo \glssymbol{mof}. OCL es componente clave del estándar \glssymbol{omg} para la transformación de los modelos \gls{qvt}. Otros lenguajes de transformación de modelos
como \gls{atl} también están construidos utilizando OCL}
}

\newglossaryentry{uml}{
	name={UML - Unified Modeling Language}, 
	text={Lenguaje Unificado de Modelado (\textit{UML} de Unified Modeling Language)},
	symbol={UML},
	description={es un lenguaje gráfico para visualizar, especificar, construir y documentar un sistema de software. Es el lenguaje de modelado de sistemas de software más conocido y utilizado en la actualidad y es también el estándar oficial, respaldado por el \glssymbol{omg}}
}

\newglossaryentry{pde}{
	name={PDE - Plug-in Development Environment},
	text={Plug-in Development Environment (\textit{PDE})},
	symbol={PDE},
	description={es un ambiente de construcción de Plugins Eclipse confeccionado por un conjunto de herramientas para crear, desarrollar, probar, depurar, construir y desplegar plug-ins, fragmentos, características, sitios de actualización y otros productos Eclipse}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Siglas              %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newacronym{ieee}{IEEE}{Institute of Electrical and Electronics Engineers}
\newacronym{ide}{IDE}{Entornos de Desarrollo Integrados o Integrated Development Environment}
\newacronym{emf}{EMF}{Eclipse Modeling Framework}
\newacronym{evl}{EVL}{Epsilon Validation Language}
\newacronym{teap}{TEAP}{Traceability Elicitation and Analysis Process}
\newacronym{alm}{ALM}{Application Lifecycle Management}
\newacronym{soa}{SOA}{Service Oriented Architecture}
\newacronym{ria}{RIA}{Rich Internet Applications}
\newacronym{rcp}{RCP}{Rich Client Platform}
\newacronym{epl}{EPL}{Eclipse Public License}
\newacronym{api}{API}{Interfaz de programación de aplicaciones o Application Programming Interface}
\newacronym{swt}{SWT}{Standard Widget Toolkit}
\newacronym{xmi}{XMI}{XML Metadata Interchange}
\newacronym{gui}{GUI}{Interfaz de Usuario Gráfica o Graphical User Interface}
\newacronym{gmf}{GMF}{Graphical Modeling Framework}
\newacronym{spl}{SPL}{Línea de Producto de Software o Software Product Line}
\newacronym{case}{CASE}{Computer Aided Software Engineering}
\newacronym{qvt}{QVT}{Query/View/Transformation}
\newacronym{dsl}{DSL}{Domain-Specific Language}
\newacronym{mmt}{MMT}{Model-to-Model Transformation}
\newacronym{atl}{ATL}{Atlas Transformation Language}



\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Título %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}

\includepdf[pages={1}]{img/caratula.pdf}

\end{titlepage}

\frontmatter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Índices %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dominitoc 
\tableofcontents
\addtocontents{toc}{~\hfill\textbf{Página}\par}
\mtcaddchapter
\clearpage

\renewcommand\listfigurename{Índice de imágenes}
\addcontentsline{toc}{chapter}{\listfigurename}
\listoffigures
\addtocontents{lof}{~\hfill\textbf{Página}\par}
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Agradecimientos %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Agradecimientos}


A mis padres, \textbf{Ana María Bloga} y \textbf{Nestor Hugo Gili}, quienes nunca dudaron en ofrecerme el soporte necesario para afrontar esta carrera de grado. A mi mujer \textbf{María Jimena Reimundo}, por brindarme el apoyo que me ayudó a terminar el trabajo de tesis al mismo tiempo que empezamos a construir nuestro hermosa familia y hogar.

\bigskip

A la \textbf{Universidad Nacional de La Plata} y en especial a la \textbf{Facultad de Informática}, por el excelente nivel educativo al que me dio acceso. A las cátedras de \textbf{Programación} y \textbf{Programación Funcional}, que me abrieron las puertas para poder desarrollar la gratificante tarea de ayudante y colaborador de cátedra respectívamente. Al laboratorio \textbf{LIFIA}, por haberme brindado la posibilidad de realizar trabajos de investigación y de asistir a cursos extracurriculares en los que adquirí conocimientos sobre diversos temas que me resultaron apasionantes.

\bigskip

A la profesora \textbf{Claudia Pons}, por haberme introducido en el grupo de investigación de \textbf{Desarrollo Dirigido por Modelos}, desde donde definimos el tema que se presentará a lo largo de este trabajo de tesis, y por  haber sido mi guía en el desarollo del mismo, demostrándome siempre su buena predisposición en cada consulta realizada.

\bigskip

A mi familia, amigos y compañeros de estudio y del trabajo, por su acompañamiento y empujón en este último trayecto del camino que con tanto esfuerzo recorrí.

\bigskip

¡¡¡Muchas gracias a todos!!!



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Introducción %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introducción}


En la \gls{mde}, se define al modelo como artefacto principal que toma participación a lo largo de todas las tareas o procesos que conforman dicha ingeniería, ésto es, el análisis, el diseño, el desarrollo, las pruebas, el mantenimiento, etc. Una implementación particular propuesta por el \gls{omg} que acompaña esta idea es la \gls{mda}, cuyo ciclo de proceso de desarrollo está basado enteramente en el uso de modelos formales y transformaciones que se realizan sobre dichos modelos. Una característica muy importante de todo proceso de \gls{mdd}, es lo que se conoce como \textit{\textbf{posibilidad de rastreo}} (de ahora en más en inglés \textit{\textbf{traceability}}), que ayuda y toma parte en todo lo que respecta a las relaciones que existen entre cada uno de los artefactos productos del proceso de desarrollo.

Cuando nos referimos al término artefacto, hablamos por ejemplo de un requerimiento de sistema, un componente de software, un caso de prueba, entre otros. El mantenimiento y la definición de las relaciones y dependencias que existen entre los artefactos no es una tarea fácil, constituyendo un desafío desde principios de 1970.

En el presente documento de tesis se aborda el tema de \textit{traceability}, presentando un análisis de los distintos problemas que aún se encuentran abiertos a la investigación y al debate, como así también un conjunto de soluciones propuestas que encontré a lo largo de mi investigación. Finalmente, se expone un \textit{\textbf{esquema de traceability}} con el fin de aportar un avance en el desarrollo de este tema.




\chapter{Objetivos}


El objetivo del trabajo de tesis consiste en introducir al lector en el tema de \textit{traceability}, abordando una serie de problemas que aún se encuentran abiertos a la investigación y debate en el ámbito de \glssymbol{mde}; para luego, elaborar un \textit{esquema de traceability} como aporte a la solución de dichos problemas.

Asimismo, diseñar e implementar una herramienta que pueda ser integrada a otra de desarrollo \glssymbol{mde}, y asista al desarrollador automatizando el proceso de definición de \textit{\textbf{trazas}} (de ahora en más en inglés \textit{\textbf{tracelinks}} o \textit{\textbf{links}}) entre elementos de los modelos origen y destino. Esta solución proveerá un mapa de transformaciones que permitirá determinar la procedencia de cada ítem del modelo destino, y su correspondiente origen en el modelo fuente.


\mainmatter
% encabezados
\lhead[]{CAPÍTULO \thechapter. \leftmark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Traceability %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Traceability}
\markboth{Traceability}{}

\begin{quotation}
En este primer capítulo, a modo de introducción se define el concepto de \textit{traceability} y se exponen, por un lado los beneficios de su aplicación, y por otro los inconvenientes que supone su implementación.
\end{quotation}

\bigskip

\minitoc 

\pagebreak

\section{Introducción}

Según el Glosario Estándar de Términos de la Ingeniería de Software del \gls{ieee} \cite{IEEE} la idea de \textit{traceability} se define como: 
\begin{quote}
\small \textit{El grado o nivel en el cual una relación puede ser establecida entre dos o más productos del proceso de desarrollo, especialmente entre productos que tengan una relación de predecesor-sucesor o principal-secundario; por ejemplo el grado en el cual el requerimiento y el diseño de un componente de software se corresponden}.
\end{quote}

La definición anterior es utilizada principalmente por \textit{The Requirements Management Community}. Nosotros, quienes necesitamos un punto de vista más cercano al contexto de \glssymbol{mdd}, usamos el término \textit{traceability} para describir 
\begin{quote}
\small \textit{\textbf{cualquiera de las complejas relaciones lógicas que existen entre los distintos artefactos que se presentan en cualquier momento del ciclo de vida del desarrollo de software, el establecimiento de estas relaciones y/o el mantenimiento de las mismas}}.
\end{quote}

Esta definición incluye a todos los productos creados durante el proceso de desarrollo, de despliegue o implantación, y también los creados a lo largo del mantenimiento. Además necesita que la información de \textit{traceability} sea accesible a lo largo de toda la vida del producto de software.


En la ingeniería de software encontramos dos usos o semánticas principales que dependen del contexto de \textit{traceability}:

\begin{itemize}

\item \textit{\textbf{traceability en la Ingeniería de Requerimientos}}: donde se guarda un requerimiento desde su definición hasta su implementación. En más detalle según \cite{GotelFinkelstein} se refiere a la habilidad de describir y seguir la vida de los requerimientos en ambas direcciones, hacia delante y hacia atrás (\textit{forward and backward traceability}). Desde los orígenes, pasando por el desarrollo y la especificación, hacia su posterior entrega y uso, y a través de todos los períodos de refinamiento e iteración de cualquiera de estas etapas.

\item \textit{\textbf{traceability en \glssymbol{mdd}}}: donde se almacenan principalmente las relaciones existentes entre los artefactos producto de las transformaciones de modelos.

\end{itemize}


Las relaciones de \textit{traceability} pueden ser definidas de forma automática, por ejemplo producto de una transformación de modelos, o de forma manual como el caso de una relación de implementación entre un requerimiento y un componente de software.

Entre numerosos beneficios de \textit{traceability}, que se expondrán en detalle más adelante, podemos encontrar que ayuda a identificar las relaciones y dependencias que existen entre los artefactos de software. También \textit{traceability} es crucial entre los requerimientos y su representación en los modelos para asegurar que el conjunto relevante de requerimientos fueron debidamente implementados en el código. Pero no solo \textit{traceability} asegura la identificación de objetos y elementos relacionados, también puede facilitar el análisis de impactos de cambios durante el desarrollo de software.

Por todo lo anterior, queda demostrado que una buena solución de \textit{traceability} que se encuentre provista de información actualizada será un servicio muy valioso tanto para jefes de proyectos, como para desarrolladores de software y/o consultores de mantenimiento.




\subsection{Beneficios}

A continuación se listan un conjunto de actividades que provienen de distintos dominios de la ingeniería, en las cuales el uso de \textit{traceability} es muy beneficioso según \cite{BrcinaRiebisch} y \cite{GrammelVoigt}.

\begin{itemize}

\item \textit{\textbf{Análisis de Sistemas}} Ayuda a entender la complejidad de un sistema, navegando el modelo de \textit{tracelinks} resultante de la ejecución de las distintas cadenas de transformación.

\item \textit{\textbf{Análisis de Cobertura}} Por ejemplo en el momento de ejecución de los casos de prueba, el uso de \textit{traceability} es crucial a la hora de determinar si todos los requerimientos fueron cubiertos, es decir tenidos en cuenta.

\item \textit{\textbf{Análisis de Impacto de Cambios}} \textit{Traceability} nos ayuda a ver cómo los cambios en un modelo repercutirán en los modelos relacionados; también el uso de \textit{traceability} nos permite saber en cualquier momento el tipo de dependencia que existe entre las entidades relacionadas, lo cual ayuda a determinar la necesidad de un cambio.

\item \textit{\textbf{Análisis de Huérfanos}} Permite encontrar fácilmente los elementos huérfanos de un modelo, pues serán aquellos artefactos que no se encuentren relacionados a ningún \textit{tracelink}.

\item \textit{\textbf{Comprensión del Software y la Ingeniería Inversa}} \textit{Traceability} es crucial cuando se necesita identificar todas las entidades relacionadas a una en particular, entender el tipo de relación existente, identificar las abstracciones, es decir los patrones de diseño y/o estilos de arquitectura, etc.

\item \textit{\textbf{Análisis de Requerimiento}} \textit{Traceability} por ejemplo ayuda a identificar el artefacto particular que demanda una propiedad específica; como así también a encontrar y resolver un conjunto de requerimientos contradictorios, entre otros.

\item \textit{\textbf{Apoyo en la toma de decisiones}} Para justificar una decisión dado que nos facilita el entendimiento de los factores y metas que influyen en la misma; también \textit{traceability} nos será muy útil en el análisis y evaluación de distintas propuestas de solución que se nos puedan presentar.

\item \textit{\textbf{Configuración del Sistema y Versionado}} El uso de \textit{traceability} es beneficioso para identificar: las restricciones entre los componentes, los cambios necesarios para resolver una restricción, las diferencias entre dos versiones distintas de un mismo artefacto y el impacto que estas diferencias tendrán sobre otros artefactos.

\end{itemize}


\subsection{Algunos inconvenientes}

Más allá de las numerosas ventajas que el uso de \textit{traceability} ha demostrado hoy en día, su puesta en práctica apenas se ha establecido. Las principales razones de ello, se deben según \cite{GrammelVoigt} a:

\begin{itemize}

\item El \textit{\textbf{alto costo}} de la creación de la información de \textit{traceability}.

\item La necesidad de \textit{\textbf{mantenimiento manual}} de la información de \textit{traceability}.

\item La \textit{\textbf{falta de heurísticas}} que determinen qué información de los \textit{links} deben ser grabados.

\item Las discrepancias entre los distintos \textit{\textbf{roles}} que ejercen los usuarios de la información de \textit{traceability}, por ejemplo entre quienes crean los \textit{tracelinks} y quienes los interpretan.

\item La carencia de \textit{\textbf{soporte adecuado de las herramientas}}.

\item El uso de \textit{\textbf{diferentes lenguajes}}, dado que por ejemplo los requerimientos se escriben en lenguaje natural mientras que los programas en algún lenguaje formal de programación.

\item Las diferencias entre los distintos \textit{\textbf{niveles de abstracción}} en los cuales los artefactos describen el sistema de software, por ejemplo el nivel de abstracción de los artefactos usados durante el ciclo de diseño difiere de los niveles usados en las etapas de implementación.

\end{itemize}

Más adelante en el capítulo \ref{cap:ProblemasDesafios} se presentarán con más detalle los desafíos presentes en la implementación y uso de \textit{traceability}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Teoría de traceability %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Teoría de traceability}
\markboth{Teoría de traceability}{}


\begin{quotation}

En el presente capítulo se aborda un conjunto de temas importantes de la teoría de \textit{traceability}, en la primera sección se explica el concepto de \textit{\textbf{nivel de granularidad}} de un \textit{tracelink}. Las siguientes dos secciones se refieren a la \textit{\textbf{semántica de traceability}}, introduciendo primero las dos distintas estrategias de \textit{\textbf{meta-modelos de traceability}} que existen, y luego, la compleja tarea de la definición de \textit{\textbf{tipos de tracelinks}}. En la sección siguiente, se presentan dos formas distintas de \textit{\textbf{generación de tracelinks}}, y en la última, las dos principales \textit{\textbf{estrategias de almacenamiento}}  de la información de \textit{traceability} que se pueden implementar. Estos temas han sido muy importantes y relevantes a la hora de definir el \textit{esquema de traceability} propuesto que se detalla en el capítulo \ref{cap:Propuesta}.

\end{quotation}


\bigskip


\minitoc 


\pagebreak


\section{Nivel de Granularidad}
\label{sec:NivelGranularidad}

El término granularidad se refiere al nivel o grado de detalle en el cual un \textit{tracelink} se genera y/o se registra, es una característica íntimamente relacionada con el uso que se le quiera dar a \textit{traceability}. Por ejemplo cuando se desee trabajar sobre diagramas de clases \glssymbol{uml}, se podrán generar \textit{tracelinks} a nivel de paquetes, de clases o de métodos. La granularidad de un \textit{tracelink} (de ahora en más en inglés \textit{\textbf{trace granularity}}) es definida por la granularidad del artefacto origen y la granularidad del artefacto destino.

Esta propiedad debe ser definida cuidadosamente para efectivamente dar un buen soporte en las tareas de \textit{traceability}, dado que es un factor que determinará la complejidad, y por tanto el esfuerzo, en el análsis y en la utilización del conjunto de los \textit{tracelinks} obtenidos.




\section{Meta-modelos de traceability}

Para llegar a la definición de cualquier propuesta de \textit{traceability} se necesita de un modelo en el cual se especifiquen los conceptos, las reglas y las relaciones que existen, por ejemplo entre los artefactos y los \textit{tracelinks}. Éste modelo de \textit{traceability} va a estar determinado por un meta-modelo, el cual puede llegar a ser clasificado como un \textit{\textbf{meta-modelo de traceability de propósito general}}, o como un \textit{\textbf{meta-modelo de traceability de caso específico}}, a continuación se explica cada uno.

\subsection{Meta-modelo de propósito general}
\label{subsec:MetaModeloPropositoGeneral}

En este caso, nos encontramos con un meta-modelo genérico que permite la \textit{\textbf{captura de tracelinks}} entre cualquier tipo de elementos de un determinado modelo. Un \textit{tracelink} se puede conectar con cualquier número de elementos, de cualquier tipo y de cualquier modelo. Las principales ventajas de este tipo de meta-modelo son la simplicidad y la uniformidad (dado que todos los modelos conforman el mismo meta-modelo), con lo cual se mejora la interoperabilidad de las herramientas otorgándoles la capacidad de importar, exportar y gestionar información de \textit{traceability} en un formato común.

Por otro lado, como el \textit{meta-modelo de propósito general} no capta casos específicos de \textit{tracelinks} fuertemente tipados, es decir sin semántica y restricciones definidas rigurosamente, se abre la puerta a establecimientos de \textit{links} ilegítimos. Como por ejemplo, en el caso de \textit{tracelinks} entre un diagrama de clases y un modelo de base de datos relacional en donde existirán vínculos entre las clases del primer modelo y las tablas del segundo, un meta-modelo de \textit{traceability} genérico permitirá el establecimiento de \textit{links} ilegítimos entre una clase y una columna.

Para permitir un mejor soporte para el caso de los requisitos específicos, es un método de uso frecuente la provisión de mecanismos de extensión que acompañan el meta-modelo de propósito general. Sin embargo, todavía carecen de la eficacia que ofrecen los \textit{meta-modelos de casos específicos} para capturar estos tipos de situaciones que requieran tal nivel de legitimidad entre la información y su semántica.

\subsection{Meta-modelo de caso específico}

En este caso, para cada escenario de \textit{traceability} se define un meta-modelo específico. Este meta-modelo de \textit{traceability} captura \textit{links} fuertemente tipados para casos específicos con una semántica bien definida, que pueden o no incluir restricciones de corrección. Debido a su naturaleza de tipado fuerte y a las restricciones asociadas, limita a los usuarios y a las herramientas para que sólo puedan establecer \textit{links} legítimos. Por otro lado, la definición de un meta-modelo para cada caso específico requiere de mucho esfuerzo en su construcción, así como el uso de herramientas que soporten, o mejor dicho, ofrezcan la posibilidad de aceptar diferentes meta-modelos de \textit{traceability}.

Para ser fuertemente tipado el meta-modelo de \textit{traceability} necesita referir explícitamente a los tipos de elementos que se encuentran definidos en otros meta-modelos. Por ejemplo, consideremos que es necesario definir un meta-modelo de \textit{traceability} que permita el establecimiento de enlaces entre instancias de \textsf{A} (del meta-modelo \textsf{MMa}) e instancias de \textsf{B} (a partir de \textsf{MMb}), pero no entre dos instancias de \textsf{A} o dos de \textsf{B}. Para lograr tal meta-modelo, la tecnología de modelado que se use no debe tomar cada meta-modelo como un espacio cerrado, sino que por el contrario debe permitir referencias \textit{inter-meta-modelo}. Un ejemplo de tecnología que soporta referencias \textit{inter-meta-modelo} es el framework \gls{emf}.

Mas allá de que un meta-modelo de \textit{traceability} (que fue definido utilizando una tecnología que permite referencias \textit{inter-meta-modelo}) puede brindar tipos seguros, encontramos frecuentemente otras restricciones que necesitan especificarse y que dicho meta-modelo no puede capturarlas. Por ejemplo, tomando como referencia el ejemplo anterior, podríamos precisar que cada instancia \textsf{A} de \textsf{MMa} sólo se puede vincular a no más de una instancia \textsf{B} de \textsf{MMb}. Para especificar tales restricciones, se requiere un lenguaje de especificación que pueda expresar restricciones que abarquen elementos que pertenezcan a modelos definidos por diferentes meta-modelos. En la actualidad el \gls{ocl} carece de esta capacidad, ya que no proporciona las construcciones para expresiones que atraviesen modelos (\textit{cross-model}). Ejemplos de lenguajes que soportan el establecimiento con tales restricciones incluyen el \gls{evl} y el XLinkit toolkit.

La combinación de un meta-modelo de \textit{traceability} fuertemente tipado en conjunto con la verificación de restricciones \textit{inter-modelo} restringe a los usuarios y a las herramientas a establecer y mantener sólo \textit{tracelinks} con sentido, los cuales pueden ser automáticamente validados para descubrir posibles omisiones e inconsistencias. Estas cuestiones pueden realizarse ya sea durante el establecimiento de los \textit{tracelinks}, o más tarde, durante el ciclo de vida de los modelos donde ya los \textit{tracelinks} han sido establecidos.




\section{Tipos de tracelinks}

Uno de los desafíos presentados en el capítulo \ref{cap:ProblemasDesafios} (sección \ref{sec:SemanticaTracelinks}) se refiere a la definición  \textit{semántica de los tracelinks}, tarea que nos permite descubrir los distintos \textit{tipos de links} con los que nos podemos llegar a encontrar, entender su significado y uso. Es importante remarcar que la determinación de la semántica de un \textit{link} se encuentra totalmente guiada por la razón del usuario respecto de qué quiere realizar o representar con dicho \textit{link}. No predefinir la \textit{semántica de un tracelink} correctamente, puede resultar en fallas de razonamientos y/o entendimientos. Por ejemplo, un \textit{link} que muestra la relación entre un requerimiento textual y un elemento de un diagrama de caso de uso \glssymbol{uml} tiene una semántica muy distinta a la de un \textit{tracelink} que determina una relación de refinamiento dentro de un modelo de clases también \glssymbol{uml}.

La definición del conjunto de \textit{tipos de tracelinks} por lo general es fuertemente dependiente del contexto de un proyecto, por lo cual definirlo de forma fija tendrá como consecuencia una pérdida de flexibilidad para los usuarios que deseen tipar los \textit{tracelinks} solamente de acuerdo a las necesidades del proyecto o la compañía. Aún así, conforme un proyecto de desarrollo crece, la administración de la información de \textit{traceability} que en consecuencia se va generando se vuelve extremadamente compleja, una jerarquía de clasificación de dicha información resultará esencial para poder entenderla y administrarla mejor. En \cite{PaigeOlsenKolovosZschalerPower} se encuentra una propuesta de \textit{clasificación genérica de traceability} en conjunto con la descripción del proceso usado para su obtención al que llamaron \gls{teap} y que a continuación se explica en detalle.



\subsection{Una clasificación genérica de traceability}
\label{sec:ClasificacionTraceability}


Esta propuesta comienza con una clasificación o meta-modelo de \textit{traceability} inicial, luego de forma iterativa e incremental esta clasificación se va refinando de acuerdo a las siguientes tareas: obtención, análisis y clasificación. En la obtención se identifica un \textit{tracelink} y sus relaciones. En el análisis, se abstraen las principales características del \textit{link} obtenido identificando las restricciones, sus relaciones y generalizaciones. Y por último, se define la clasificación a la que pertenece.

El meta-modelo inicial se puede ver en el dibujo \ref{fig:ClasifInicial}, en el que se encuentran los siguientes conceptos fundamentales: \textsf{Artefact}, \textsf{Tracelink} y \textsf{Operation}. \textsf{Artefact} refiere tanto a artefactos \glssymbol{mde}, por ejemplo modelos específicos de dominio, como a no \glssymbol{mde}, por ejemplo hojas de cálculo. En \textsf{Operation} se encierran las operaciones tanto manuales como automáticas que determinan qué información de \textit{traceability} debe almacenarse. Por último \textsf{Tracelink} da inicio con la clasificación de \textit{\textbf{tracelink implícito}} (\textsf{Implicit Link}) por un lado, y \textit{\textbf{tracelink explícito}} (\textsf{Explicit Link}) por el otro, en donde \textit{tracelink implícito} refiere a los \textit{links} que son creados y manipulados por la aplicación de las operaciones \glssymbol{mde}, y por su parte \textit{tracelink explícito} refiere a los \textit{links} que se encuentran concretamente ya representados en los modelos.


\begin{figure}[hbtp]
\centering
\includegraphics[scale=1.05]{./img/ExplicitImplicitTraceLinkClassification}
\caption{Clasificación de traceability inicial}
\label{fig:ClasifInicial}
\end{figure}

\subsubsection{Clasificación de tracelinks implícitos}


En esta jerarquía que se muestra en el dibujo \ref{fig:LinksImplicitos} se encuentran representados el conjunto de operaciones \glssymbol{mde} principales: \textit{Consulta} (\textsf{Query Link}), \textit{Transformación modelo a modelo} (\textsf{M2M Link}), \textit{Transformación modelo a texto} (\textsf{M2T Link}), \textit{Composición} (\textsf{Composition Link}), \textit{Actualización} (\textsf{Update Link}), \textit{Creación} (\textsf{Creation Link}), \textit{Eliminación} (\textsf{Delete Link}), entre otras.


\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.56]{./img/ImplicitTraceLinks}
\caption{Jerarquía de links implícitos}
\label{fig:LinksImplicitos}
\end{figure}


\subsubsection{Clasificación de tracelinks explícitos}

En un principio esta clasificación se encuentra dividida en dos grandes grupos representados por las siguientes clases básicas: \textit{Link modelo-modelo}, que representa por ejemplo las relaciones de dependencias \glssymbol{uml}, y \textit{Link modelo-artefacto}, conjunto al que pertenece por ejemplo el \textit{link} entre un modelo y un documento de texto que dicta un requerimiento. En el dibujo \ref{fig:LinksExplicitos} aparecen como \textsf{Model-Model Link} y \textsf{Model-Artefact Link} respectivamente.

\textsf{Model-Model Link} se encuentra a su vez subdividido en \textit{Link estático} (\textsf{Static Link}) y \textit{Link dinámico} (\textsf{Dynamic Link}). En el primero se representan relaciones estructurales que no cambian con el tiempo, en cambio en el segundo se representa información de los modelos que si puede llegar a variar.

Los \textit{links estáticos} pueden ser, o \textit{Links consistentes} (\textsf{Consistent-With}) donde dos modelos deben mantenerse de acuerdo o consistentes entre sí, o \textit{Links dependientes} (\textsf{Dependency}) donde la estructura y/o la semántica de un modelo depende de otro. Por su parte, los \textit{Links dependientes} pueden ser: \textit{Link de subtipo} (\textsf{Is-A}), \textit{Link de referencia}, \textit{link de subconjunto}, de \textit{importación} y \textit{exportación}, de \textit{uso}, de \textit{refinamiento} (\textsf{Refines}), etcétera.

Entre los \textit{links dinámicos} se incluyen los \textit{Links de llamadas} (\textsf{Calls}) donde un modelo hace uso de métodos provistos por otro y los \textit{Links de notificación} (\textsf{Notifies}) donde es necesario almacenar información que puede ser manejada automáticamente. También encontramos aquí las relaciones en tiempo de diseño como los \textit{Links de generación o construcción} (\textsf{Generates}), que indican qué información de un modelo es usada para producir o deducir otro, y los \textit{Links de sincronización} (\textsf{Synchronized With}), donde el comportamiento de un conjunto de modelos se realiza de forma sincronizada.

El alcance de \textsf{Model-Artefact Link} es muy amplio, por tal motivo en esta clasificación sólo se resumen un subconjunto de ejemplos, entre ellos: la relación \textit{satisface} (\textsf{Satisfies}), que indica qué propiedad o requerimiento de un artefacto es satisfecha por un modelo; los \textit{Links de asignación} (\textsf{Allocated-To}), usados cuando la información de un artefacto no modelo es asignada a un modelo específico que la representa; la relación de \textit{realización} (\textsf{Performs}), que indica qué tarea descripta por un artefacto es llevada a cabo por el modelo; las relaciones \textit{explica} y \textit{respalda} (\textsf{Explains} y \textsf{Supports}) que dictan qué modelo se encuentra explicado y respaldado respectivamente por un artefacto no modelo.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.52]{./img/ExplicitTraceLinks}
\caption{Jerarquía de links explícitos}
\label{fig:LinksExplicitos}
\end{figure}




\section{Generación de tracelinks}
\label{sec:GeneracionTracelinks}

Uno de los principales temas de \textit{traceability} refiere a los dos enfoques distintos de \textit{generación de tracelinks} que se pueden presentar o usar durante una transformación de modelos, estos son la generación \textit{\textbf{implícita}} y la generación \textit{\textbf{explícita}}. 

La diferencia entre estas dos posibilidades radica en que, por un lado en la generación \textit{implícita} las transformaciones proveen un soporte integrado de \textit{traceability}, mientras que por el otro, en la generación \textit{explícita} es responsabilidad del desarrollador de la transformación codificar explícitamente las reglas de \textit{traceability} que generarán esta información como un modelo más de salida.

A continuación se detallan las ventajas y desventajas de cada enfoque según \cite{GrammelVoigt}:


\subsection{Generación implícita}

\paragraph{Ventajas}

\begin{itemize}[label={\checkmark}]

\item La única y gran ventaja de la generación \textit{implícita} es que no es necesario ningún esfuerzo adicional para obtener los \textit{tracelinks} que relacionan los modelos de entrada y salida, dado que son generados en paralelo y automáticamente con el modelo resultante de la ejecución de la transformación.

\end{itemize}

\paragraph{Desventajas}

\begin{itemize}[label={$\times$}]

\item El meta-modelo de \textit{traceability} tiene que ser necesariamente fijo, pero dada la infinidad de enfoques de transformaciones que dan lugar a diferentes definiciones de meta-modelos, lograr un estándar entre estos diferentes enfoques es muy complejo.

\item Dada la poca flexibilidad que se obtiene al hacer uso de un meta-modelo fijo, se presentan los siguientes inconvenientes a tener en cuenta:

\begin{itemize}

\item[-] cuando se generan \textit{tracelinks} para todos los elementos del modelo referenciado, obtener una cantidad considerable de ellos puede volverse incomprensible y en consecuencia inútil. También, en el caso de transformaciones de modelos grandes y complejos, podemos encontrarnos con problemas de rendimiento.

\item[-] la configuración del nivel de \textit{trace granularity} varía de un escenario de \textit{traceability} a otro.

\item[-] un cliente, por ejemplo aduciendo a motivos de seguridad, puede requerir que para cierta información de un modelo no se le generen \textit{tracelinks}.

\end{itemize}

\end{itemize}

\subsection{Generación Explícita}

\paragraph{Ventajas}

\begin{itemize}[label={\checkmark}]

\item Es posible el tratamiento de \textit{traceability} como un modelo regular complementario al resultado de la transformación, que se puede obtener por la incorporación de reglas de transformación adicionales. Por lo cual, la elección del meta-modelo es responsabilidad completa del programador de la transformación y no depende del motor de transformaciones. 

\item Dada la flexibilidad del meta-modelo, el nivel de \textit{trace granularity} de los \textit{tracelinks} es fácil de adaptar al dominio de la transformación.

\end{itemize}

\paragraph{Desventajas}

\begin{itemize}[label={$\times$}]

\item Se requiere de un esfuerzo adicional para definir las reglas de transformación específicas para \textit{traceability}, que en consecuencia contaminan la implementación.

\item Como la definición de las reglas de \textit{traceability} es responsabilidad del programador, es propensa a errores y puede llegar a demandar mucho tiempo. Más aun si pensamos que esta tarea se tiene que repetir para cada transformación que se requiera.

\end{itemize}


\section{Estrategias de almacenamiento}

Según \cite{DrivalosPaigeFernandesKolovos} hay dos tipos principales de estrategias a seguir para almacenar y administrar la información de \textit{traceability}, \textit{\textbf{almacenamiento intra-modelo}} y \textit{\textbf{almacenamiento externo}}. En la primera, la información de \textit{traceability} se encuentra embebida en los modelos a los que ella hace referencia. En cambio en la segunda, dicha información se encuentra almacenada de forma separada de los modelos:

\subsection{Almacenamiento intra-modelo de tracealinks}

Como ya se dijo, bajo esta estrategia la información de \textit{traceability} es almacenada dentro de los modelos a los que hace referencia, esto puede ser mediante elementos pertenecientes al modelo o mediante atributos (como etiquetas o propiedades).

Es una estrategia sencilla y amigable, pero puede ser muy problemática por varias razones. Si los \textit{tracelinks} son dirigidos y almacenados solamente en el modelo origen, éstos no son visibles en el modelo destino, a la inversa (almacenados en el destino) nos encontramos con el mismo problema pero en el origen. Por otro lado, si la información de \textit{traceability} es almacenada en ambos modelos, entonces nos encontramos con el desafío de que dicha información se mantenga consistente por cada cambio que se suceda.

A todo lo anterior, se suma el problema de la polución que se genera en el modelo con la información de \textit{traceability}, dado que la misma es ajena a su contexto. Dicha polución puede incluso lograr que el modelo se vuelva imposible de comprender y mantener.

Por otro lado, en un entorno \glssymbol{mde} es común que los modelos tengan sus propias representaciones y semánticas, lo cual puede volver más compleja la tarea de diferenciar la información de \textit{traceability} de los objetos que representan el modelo del dominio.

Como resultado de los inconvenientes anteriores, el análisis automatizado de la información de \textit{traceability} se hace muy difícil. Las principales metodologías que hacen uso de esta estrategia utilizan construcciones de lenguaje específicas, por ejemplo determinados tipos de enlaces de \textit{traceability} están representados en los diagramas \glssymbol{uml} mediante el uso de estereotipos como \textsf{<<refines>>}.

\subsection{Almacenamiento externo de tracelinks}

En esta estrategia la información de \textit{traceability} se encuentra almacenada de forma separada a los modelos a los que hace referencia, en un modelo aparte. Esta propuesta tiene dos ventajas claras, la primera es que los modelos origen y destino se mantienen totalmente limpios, con lo cual la polución del \textit{almacenamiento intra-modelo} no sucede. Y la segunda, dado que el modelo en donde se almacenan los \textit{tracelinks} se encuentra definido por un meta-modelo con una semántica clara, logra que el proceso de análisis de la información sea mucho más fácil que en la otra estrategia.

Un requisito previo para el \textit{almacenamiento externo de los tracelinks}, es que los diferentes elementos del modelo tengan identificadores únicos, de modo que los \textit{links} que los relacionan se puedan resolver inequívocamente. Un ejemplo es el mecanismo propuesto por \gls{mof} y \gls{emf} en la forma de un identificador \textsf{xmi.id}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Problemas y Desafíos %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Problemas y Desafíos}
\label{cap:ProblemasDesafios}
\markboth{Problemas y Desafíos}{}

\begin{quotation}
En este capítulo se describe, por un lado, los principales problemas que se presentan en el ámbito de \textit{traceability} (organizados por tema según el criterio presentado en \cite{Excellence}), y por otro, los grandes desafíos que surgen a partir de ellos. Desafíos que aún hoy, se encuentran abiertos a la investigación y al debate.
\end{quotation}


\bigskip


\minitoc 


\pagebreak


\section{Conocimiento de traceability}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]

\item Existe poco consenso respecto a cuáles son las mejores técnicas y métodos para la aplicación de \textit{traceability}, escasas anotaciones y documentación sobre las mejores prácticas, sumado a una falta de recursos que provean una buena base de conocimiento.

\item Las definiciones semánticas no coinciden y las terminologías son dispares, todo ésto crea barreras de comunicación.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]

\item Crear una base de conocimiento en la que se vuelquen las mejores prácticas de \textit{traceability}, una terminología estándar y suficiente información adicional, como por ejemplo casos de estudio.

\end{itemize}

\section{Capacitación y certificación}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]
\item Se halla muy poca gente competente en la tarea de definición de \textit{tracelinks}, paralelamente es escasa la disponibilidad de programas educativos que enseñen dicha tarea.

\item Existen pocos programas de certificación, de los cuales pocos incluyen componentes de \textit{traceability}.

\item No hay definido un conjunto de estrategias estándar de \textit{traceability}.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]
\item Identificar las áreas de conocimiento y las estrategias principales asociadas a \textit{traceability}.

\item Desarrollar buenos componentes educativos para la puesta en práctica de \textit{traceability}.

\item Desarrollar materiales pedagógicos efectivos para educar poniendo énfasis  en la importancia y evaluación de los costos-beneficios que conllevan la implementación de \textit{traceability}.

\end{itemize}

\section{Soporte y evolución}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]

\item La información precisa, coherente, completa y actualizada sobre \textit{traceability} es fundamental para diversos ámbitos y aplicaciones. Sin embargo, las técnicas actuales de \textit{captura de tracelinks} aún son realizadas de forma manual y por lo tanto son propensas a errores.

\item Para que los \textit{tracelinks} sean útiles, éstos deben reflejar la dependencia actual entre los artefactos. Dado que el costo y esfuerzo para mantenerlos durante la evolución del sistema es inmenso, a menudo los \textit{tracelinks} pasan a encontrarse en un estado erróneo o incorrecto.

\item Las herramientas actuales de administración de requerimientos incluyen características como \textit{suspect tracelinks} para ayudar a los analistas a administrar y entender la evolución de los \textit{tracelinks}, pero en la mayoría de los proyectos complejos, el número de enlaces marcados como \textit{suspect tracelinks} se vuelven rápidamente excesivos, minimizándose drásticamente la utilidad de tal característica.
 
\item Los \textit{tracelinks} tienen que evolucionar de forma sincrónica con los artefactos a los que se encuentran relacionados, sin embargo los sistemas actuales de gestión de cambios y la semántica de los enlaces no son lo suficientemente sofisticados como para acompañar tal evolución.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]

\item Desarrollar técnicas de \textit{captura de tracelinks} automáticos para artefactos descriptos de forma textual, que sean tan precisos como el proceso manual y, a la vez, mucho más efectivos en tiempo y costo.

\item Desarrollar la funcionalidad de \textit{captura de tracelinks} de forma integrada a los \gls{ide}.

\item Desarrollar sistemas de administración de cambios que efectivamente acompañen la evolución de los \textit{tracelinks} sobre los múltiples tipos de artefactos que existen.

\item Desarrollar técnicas que maximicen la reutilización de los \textit{tracelinks} cuando un código existente se vuelva a utilizar en un nuevo producto.

\end{itemize}

\section{Semántica de los tracelinks}
\label{sec:SemanticaTracelinks}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]

\item Para efectivamente utilizar y entender las relaciones por debajo de \textit{traceability}, es necesario definir la semántica de los \textit{tracelinks}. Sin embargo, definir una formalidad para representar esta semántica no es una tarea fácil y puede llegar a quedar acotada a un dominio específico, cosa que no es conveniente.

\item Es muy importante para mantener la consistencia en \textit{traceability}, conocer y establecer el nivel de \textit{trace granularity}. El problema es que no existe aún, un modelo claro de costo-beneficio que determine unívocamente cuál es el nivel correcto.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]

\item Definir meta-modelos para representar la información semántica de los \textit{tracelinks} y proveer ejemplos de instancias sobre distintos dominios específicos.

\item Desarrollar técnicas y procesos para determinar el correcto nivel de \textit{trace granularity} de un proyecto.

\end{itemize}

\section{Escalabilidad}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]

\item Las técnicas corrientes de \textit{traceability} no escalan adecuadamente en proyectos largos.

\item Las herramientas de visualización son esenciales para dar ayuda en la compresión y el uso de la gran cantidad de información de los \textit{tracelinks}. Sin embargo, las técnicas actuales no escalan bien y no son efectivas al presentar información compleja, dado que carecen de características sofisticadas de filtrado, navegación, consultas, etc.

\item Muchos conjuntos de datos industriales son compuestos por largos e inestructurados documentos que son difíciles de enlazar mediante \textit{tracelinks}.
\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]

\item Obtener conjuntos de datos de escala industrial desde varios dominios y usarlos para investigar la escalabilidad de las técnicas disponibles actualmente y, si es necesario, crear nuevas aproximaciones que escalen más eficientemente.

\item Desarrollar mecanismos visuales efectivos que permitan la navegación y consulta de un gran número de \textit{tracelinks} y los artefactos asociados.

\item Desarrollar técnicas escalables para marcar los \textit{tracelinks} independientemente de que el conjunto de datos sea heterogéneo, de tamaño considerable y/o se encuentre débilmente estructurado.

\end{itemize}


\section{Factores humanos}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]

\item Los métodos automáticos de \textit{traceability} por lo general trabajan produciendo \textit{tracelinks} candidatos. Sin embargo, el proceso es inútil si el analista no es capaz de evaluarlos correctamente y lograr diferenciar los buenos de los malos, o si no puede confiar en la completitud y precisión de los resultados.

\item Idealmente la captura de \textit{tracelinks} debería ser invisible durante todo el proceso de desarrollo. Sin embargo, la generación y el uso de los \textit{tracelinks} es continuamente interrumpido por interacciones humanas dado que, en los ambientes de desarrollo actuales, aún no es posible automatizar todo el proceso.

\item Los \textit{tracelinks} por lo general enlazan artefactos semánticamente diferentes, a su vez estos artefactos son creados por diferentes personas y frecuentemente escritos en diferentes documentos. Como resultado, los usuarios de un lado de los \textit{tracelinks} no entienden bien los artefactos que pertenecen al otro lado de la relación.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]

\item Basándose en el estudio del uso de las herramientas actuales de \textit{traceability}, crear nuevas que reúnan las necesidades prácticas que vayan surgiendo.

\item Entender las vulnerabilidades a fallas humanas y sus impactos del proceso de \textit{traceability}, y desarrollar técnicas que ayuden a los analistas a prevenir tales errores y/o minimizar el impacto de los mismos cuando ocurran.

\item Desarrollar técnicas que ayuden a las personas a superar las barreras semánticas que se pueden presentar en el proceso de desarrollo completo.

\end{itemize}

\section{Análisis de costo-beneficio}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]

\item En un escenario de \textit{traceability} completo, los \textit{tracelinks} son creados entre artefactos que se encuentran en un nivel bajo de abstracción, lo que puede ser deseable para propósitos de comprensión, sin embargo este nivel tan bajo no es por lo general práctico ni efectivo en términos de costo.

\item Se carece de un modelo de costo-beneficio que ayude en el análisis que sea necesario realizarse sobre un proyecto cualquiera que implemente y/o use \textit{traceability}, que guíe, por ejemplo, en el tratamiento y selección de un conjunto de \textit{tracelinks} potenciales que puedan surgir de un proyecto.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]

\item Definir y desarrollar técnicas de generación y mantenimiento de la información de \textit{traceability} eficientes.

\item Definir un modelo de costos que sea práctico y aplicable en la generación y el mantenimiento de los \textit{tracelinks}, que tome en consideración factores tales como el tamaño del proyecto, el tiempo, el esfuerzo y la calidad.

\item Definir un modelo de beneficios del uso de \textit{tracelinks}, que tome en consideración la crítica y la volatilidad, e incorpore el valor logrado gracias al uso de \textit{traceability}.

\end{itemize}

\section{Métodos y herramientas}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]

\item Los métodos de recuperación de \textit{tracelinks} que relacionan artefactos multimedia no son lo suficientemente sofisticados y/o soportados. Más aún, se ha realizado poco por incorporar tales técnicas multimedia en las herramientas de \textit{traceability}.

\item Que \textit{traceability} sea automático es esencial, sin embargo, su puesta en práctica se hace difícil dada la falta de consistencia entre los artefactos relacionados y la imprecisión de los modelos.

\item El uso de \textit{traceability} implica todas las siguientes actividades: construcción y/o generación, evaluación, mantenimiento y uso de los \textit{tracelinks}. Sin embargo, no existe aún una sola herramienta que pueda cubrir todas estas tareas por completo.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]

\item Desarrollar métodos efectivos que enlacen artefactos multimedia.

\item Construir métodos y herramientas con altos niveles de automatización que soporten el ciclo de vida entero: la construcción, la evaluación, el mantenimiento y el uso de los \textit{tracelinks}.

\item Desarrollar métodos de \textit{traceability} que den soporte a requerimientos no funcionales.

\end{itemize}

\section{Procesos}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]

\item \textit{Traceability} no se incluye frecuentemente como una parte integral del ciclo de vida del desarrollo.

\item \textit{Traceability} automático provee una alternativa eficiente en comparación a la metodología manual, sin embargo la práctica ha mostrado que algunos conjuntos de datos  son difíciles de procesar en la obtención de \textit{tracelinks}, ésto se debe a las inconsistencias en terminología y estándares, la carencia de estructuras, los formatos heterogéneos, etc.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]

\item Construir modelos de proceso que definan el ciclo de vida completo de \textit{traceability}.

\item Desarrollar técnicas que permitan evaluar la posibilidad/capacidad que tiene un determinado conjunto de datos de soportar los métodos automáticos de \textit{traceability}.
 
\end{itemize}

\section{Conformidad}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]

\item El uso de estándares aseguran procesos consistentes y completos, aunque abundan los estándares en el ámbito de \textit{traceability}, no está claro si los investigadores y/o profesionales están completamente consientes de la existencia de los mismos.

\item En la comunidad de \textit{traceability} se encuentran eruditos sobre técnicas y procesos del tema, pero tienen poca influencia sobre los contenidos de \textit{traceability} relacionados con los procesos estándar de ingeniería de software.

\item No está claro cómo se puede demostrar el cumplimento de los estándares y regulaciones.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]

\item Establecer un mecanismo de comunicación para hacer que la comunidad de expertos de \textit{traceability} dictamine los estándares relacionados con la tecnología.

\item Sumarse a la comunidad que define normativas y estándares con el fin de influir y/o desarrollar los estándares de \textit{traceability}.

\item Como comunidad, desarrollar y promover escenarios válidos para probar que las herramientas, las técnicas y las metodologías de \textit{traceability} cumplen con los estándares.

\end{itemize}


\section{Mediciones y Benchmarks}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]

\item Los estudios empíricos se necesitan para demostrar la eficacia de los métodos de \textit{traceability} y así, facilitar el trabajo colaborativo y evolutivo entre los investigadores y profesionales. Sin embargo, no se dispone de diseños comunes de experimentación, metodologías, ni \textit{cotas de referencia} (de ahora en adelante en inglés \textit{benchmarks}) para poder realizar dichos estudios.

\item Los \textit{benchmarks}, métodos y métricas propuestas actuales no han sido validadas a través de estudios o pruebas empíricas.

\item No existen o no se han realizado buenas pruebas y \textit{benchmarks} para \textit{traceability} y, las que existen, no son compatibles. 

\item No existen \textit{benchmarks} que ayuden en la comparación de métodos y técnicas ya definidas y desarrolladas de \textit{traceability}.

\item La detección de errores en los \textit{tracelinks} determina la eficacia del producto y del proceso, sin embargo los modelos de detección de errores actuales son primitivos e inválidos.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]

\item Definir procesos estándares para la realización de estudios empíricos en el ambiente de investigación de \textit{traceability}.

\item Crear \textit{benchmarks} para evaluar los métodos y las técnicas de \textit{traceability}.

\item Definir medidas que ayuden en la evaluación de calidad de \textit{tracelinks}, tanto de uno como de un conjunto de ellos.

\item Desarrollar técnicas de evaluación de métodos y procesos de \textit{traceability}.

\end{itemize}

\section{Transferencia de tecnología}

\subsubsection{Problemas}

\begin{itemize}[label={$\times$}]

\item Uno de los objetivo de la investigación de \textit{traceability} es lograr transferir soluciones eficaces a la industria. Sin embargo, en la realidad en la industria son reacios a probar técnicas nuevas donde la eficacia aún no fue demostrada.

\item La carencia de diálogo entre los investigadores y los profesionales limita, por un lado a los investigadores a acceder a un conjunto de datos reales para testear nuevas técnicas, y por otro, inhibe la retroalimentación de la industria hacia los investigadores.

\item Los prototipos de \textit{traceability} son generalmente diseñados para mostrar pruebas de conceptos en el campo de la investigación. Sin embargo, estos prototipos no son lo suficientemente rigurosos para el campo de pruebas de la industria.

\end{itemize}

\subsubsection{Desafíos}

\begin{itemize}[label={\checkmark}]

\item Crear una infraestructura y un conjunto de métodos relacionados con el fin de organizar el proceso de transferencia de tecnología.

\item Identificar los casos de estudio exitosos y darlos a conocer con el fin de demostrar la eficacia de rentabilidad y técnica que ofrecen las metodologías de \textit{traceability} en el ámbito industrial.

\item Identificar a los usuarios de \textit{traceability} y definir sus necesidades en términos de calidad, ciclo de vida, comunicación, etc.

\item Incorporar las herramientas de \textit{traceability} que se encuentren a la vanguardia en los \glspl{ide} más comunes (como \textsf{Eclipse}) y en las herramientas de administración de requerimientos industriales.

\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Propuesta %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Manos a la obra}
\label{cap:Propuesta}
\markboth{Manos a la obra}{}

\begin{quotation}
En este capítulo se introduce, desarrolla y fundamenta el \textit{esquema de
traceability} propuesto en este trabajo de tesis. Del mismo modo se expone el prototipo de la herramienta construida que acompaña y ejemplifica las ideas del esquema presentado. Dicha herramienta, desarrollada como un \textit{\textbf{plug-in}} del \glssymbol{ide} \textsf{Eclipse}, asiste en la generación de \textit{tracelinks} sobre transformaciones de modelos existentes, y luego, presenta un mapa en el que se muestra la manera en que se relacionan las transformaciones, los \textit{links} y los artefactos orígenes y resultados de la ejecución de las transformaciones.
\end{quotation}


\bigskip


\minitoc 


\pagebreak


\section{Requerimientos}


\subsection{Introducción}
\label{sec:EsquemaPropIntro}

La idea fundamental es lograr un meta-modelo bien simple en el que se capturen solamente los conceptos más relevantes de \textit{traceability} y se almacene la información mínima necesaria. Gracias a todo lo anterior, y solo así, logramos obtener el concepto deseable de independencia del modelo con respecto al dominio en el que se quiera utilizar la funcionalidad de \textit{traceability}. Concepto necesario para poder llegar a definir un \textit{esquema de propósito general} (\ref{subsec:MetaModeloPropositoGeneral}) que apunte principalmente a dar solución a los siguientes desafíos:

\begin{itemize}

\item Lograr un esquema que represente el conjunto de \textit{tracelinks} independientemente de cómo fueron generados, \textit{explícita} o \textit{implícitamente} (\ref{sec:GeneracionTracelinks}), su \textit{trace granularity} (\ref{sec:NivelGranularidad}) y/o semántica.

\item Mantener la comunicación lo más simple posible, tanto sea la que se realiza entre los distintos usuarios con sus respectivos roles, como la de los distintos tipos de herramientas que necesiten aplicar \textit{traceability}.

\item Cuando se desee agregar la funcionalidad de \textit{traceability} mediante el uso de este esquema, la adaptación de la herramienta, cualquiera sea, tiene que ser una tarea sencilla.

\item Aún dada la infinidad de artefactos que se pueden presentar, el esquema siempre tiene que ofrecer información semántica de los mismos, con el fin de facilitar la validación de los \textit{links} legítimos.

\item Lograr identificar unívocamente cada artefacto sobre el que se desee realizar \textit{traceability}.

\end{itemize}

\section{El esquema de traceability propuesto}
\label{sec:EsquemaTraceability}

Con el fin de cumplir con las consignas fundamentales listadas en \ref{sec:EsquemaPropIntro}, se definió una propuesta de \textit{esquema de traceability} que se encuentra representado en el diagrama de clases del dibujo \ref{fig:EsquenaPropuesto}.

Como se puede observar, el meta-modelo se puede dividir lógicamente en dos partes, la principal en la que se encuentran las abstracciones fundamentales de los elementos mínimos necesarios en cualquier herramienta que desee ofrecer \textit{traceability}, y una secundaria en la que se engloba la configuración del esquema. Esta configuración permite ofrecer un meta-modelo flexible a cualquier escenario/dominio en el que se desee hacer uso de \textit{traceability}.


\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.76]{./img/Esquema}
\caption{Esquema de traceability propuesto}
\label{fig:EsquenaPropuesto}
\end{figure}


\subsubsection{Clases fundamentales}

Entre los elementos fundamentales se encuentra la clase \textsf{TraceLink}, la cual representa un tracelink. Esta clase está compuesta por un nombre que sirve como identificador (\textsf{name}), un tipo con el cual se determina su semántica (\textsf{type}), una referencia de la transformación a la que pertenece (\textsf{transformation}) la cual es optativa porque un tracelink puede o no ser producto de una transformación, y por último dos conjuntos de artefactos: el de los orígenes/fuentes (\textsf{sources}) y el de los objetivos/resultados (\textsf{targets}).

Los artefactos se encuentran representados por la clase \textsf{Artefact}, cuya identificación también pasa por su nombre (\textsf{name}), su descripción también por un diccionario de clave-valor, y por último su semántica también puede ser definida por un tipo definido en la configuración.

Por último entre los elementos fundamentales, tenemos la clase \textsf{Transformation} que abstrae de las transformaciones un nombre para su identificación, una descripción vía un diccionario y la colección \textsf{traceLinks} que son producto de su ejecución.


\subsubsection{Configuración del esquema}

Esta parte refleja la configuración necesaria para lograr un esquema adaptable a la infinidad de escenarios en los que puede aplicarse el mismo. Dicha configuración consiste en la definición de dos jerarquías, una en la que se define la semántica de los artefactos que se van a \textit{\textbf{tracear}}, y la otra para determinar la semántica de los \textit{tracelinks} que pueden llegar a crearse. Ambas jerarquías están determinadas mediante las clases \textsf{LinkType} y \textsf{TypeArtefact} respectivamente, éstas comparten la siguiente estructura: un nombre (\textsf{name}) que las identifica, un texto que posibilita describirlas (\textsf{description}) y una relación (\textsf{parent}) que asocia una clasificación con su padre, gracias a dicha relación se logra la estructura jerárquica.

Un ejemplo de una configuración de tipos de \textit{tracelinks} puede ser la jerarquía propuesta en la sección \ref{sec:ClasificacionTraceability}, que se puede ver siguiendo los diagramas \ref{fig:ClasifInicial}, \ref{fig:LinksImplicitos} y \ref{fig:LinksExplicitos}.


\subsection{Lo que no ofrece}

A continuación se lista un conjunto de aspectos y/o funcionalidades que el esquema propuesto actual no ofrece o no tiene en cuenta:

\begin{itemize}

\item \textbf{\textit{funcionalidad de versionado}}: que permita navegar por los \textit{tracelinks} y refleje las modificaciones en el tiempo que se fueron realizando sobre los artefactos relacionados, a lo largo de la ejecución de todas las tareas que forman parte de la ingeniería de un software.

\item \textbf{\textit{métodos de detección o información de errores}}: que determinen o informen cuándo un \textit{tracelink} es inválido.

\end{itemize}


\section{El prototipo}

En la presente sección se explica y presenta el prototipo desarrollado que materializa la idea detrás del \textit{esquema de traceability} propuesto en la sección \ref{sec:EsquemaTraceability}.


\subsection{La herramienta}

La idea es lograr una herramienta que, dada la definición de una transformación acompañada con el conjunto de modelos de entrada/origen y de resultado/destino, retorne y muestre de una forma amigable el mapa de \textit{tracelinks} que se generaron implícitamente producto de su ejecución. También, que permita la edición de dicho mapa posibilitando:
\begin{itemize}
\item crear, editar y eliminar \textit{tracelinks}
\item editar artefactos de los modelos origen y destino
\item editar transformaciones
\end{itemize}


\subsubsection{Uso}

A continuación se detalla cómo es la secuencia del uso de la herramienta para lograr lo explicado anteriormente, la imagen \ref{fig:SecuenciaPrototipo} muestra el resumen de la idea.

\bigskip

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.56]{./img/Secuencia_Prototipo}
\caption{Secuencia del prototipo}
\label{fig:SecuenciaPrototipo}
\end{figure}

\bigskip

Para lograr el mapa de \textit{tracelinks}, dada una definición de una transformación cualquiera \gls{qvt}, primero se debe ejecutar dicha transformación con su modelo origen, con el fin de obtener el modelo resultado. Es importante aclarar que en conjunto con el resultado de la transformación, \gls{qvt} genera implícitamente información de \textit{tracelinks} en un modelo definido por el meta-modelo que se muestra en la imagen \ref{fig:QVTTraceModel}. 

Luego, se transforma el modelo de \textit{tracelinks} de \gls{qvt} al modelo definido por la herramienta (visto en la imagen \ref{fig:EsquenaPropuesto}), para lograr ésto, el prototipo incluye una definición de una transformación llamada \textsf{QvtoTrace\_To\_Trace}.

De esta manera, ya podemos acceder al mapa de \textit{tracelinks} de la transformación que queríamos mediante la herramienta \textsf{TraceEditor}, navegar sus relaciones y realizar las ediciones que se deseen.



\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.78]{./img/QVTTraceModel}
\caption{Modelo de tracelinks de QVT}
\label{fig:QVTTraceModel}
\end{figure}



\subsection{Arquitectura}


El prototipo se encuentra definido por dos módulos: \textsf{QvtoTrace\_To\_Trace} que convierte la información de trazas \gls{qvt} en un modelo definido por el meta-modelo que usa el otro módulo, y \textsf{TraceEditor} que es el editor gráfico y tabular de la información de \textit{traceability}.

El modelo del mapa de \textit{tracelinks} (o meta-modelo) que usa la herramienta se encuentra definido según el \textit{esquema de traceability} propuesto y presentado en \ref{sec:EsquemaTraceability}. Por otro lado, el prototipo de la herramienta propuesta trabaja sólo sobre transformaciones \gls{qvt}, en el anexo \ref{cap:ATLTtraceability} se presentan algunas ideas de cómo implementar algo similar para transformaciones \gls{atl}.



\subsection{Transformación QvtoTrace{\_}To{\_}Trace}

Como ya se mencionó, esta tranformación toma como entrada un modelo de \textit{tracelinks} definido por el meta-modelo de la imagen \ref{fig:QVTTraceModel} y retorna un modelo basado en el esquema propuesto de \textit{traceability} (\ref{fig:EsquenaPropuesto}) llamado \textsf{TraceEditor} como la herramienta que lo usa y cuya definición se puede ver en la imagen \ref{fig:TraceEditorMetaModel}.


\begin{figure}[hbtp]
\centering
\includegraphics[scale=.61]{./img/TraceEditorMetaModel}
\caption{Meta-modelo TraceEditor}
\label{fig:TraceEditorMetaModel}
\end{figure}


La transformación se desarrolló con el lenguaje \gls{qvt} (en la sección \ref{sec:QVT} se detalla esta tecnología) y su definición completa se encuentra en el Anexo \ref{cap:QvtoTraceToTrace}. Esta transformación se encuentra documentada en detalle mediante comentarios incorporados en el código.



\subsection{Editor gráfico y tabular TraceEditor}

Este editor gráfico y tabular se ejecuta como un plugin de \textsf{Eclipse}, permite presentar todo el mapa de \textit{tracelinks} que se genera producto de una transformación que se quiera analizar, así como realizar algunas modificaciones sobre dicho modelo. Permite identificar fácilmente, el listado de los artefactos orígenes de una transformación, el de los destinos o resultados, el conjunto de \textit{tracelinks} agrupados por la transformación que los generó, y los artefactos orígenes y destinos que enlaza cada \textit{tracelink}. De un artefacto y de un \textit{tracelink} muestra el nombre que lo identifica y su tipo, y de una transformación sólo el nombre.

Está conformado por los siguientes componentes:

\begin{itemize}
\item Un editor gráfico
\item Un editor tabular
\item La definición de una perspectiva 
\end{itemize}


\begin{figure}[hbtp]
\centering
\includegraphics[scale=.29]{./img/TraceEditorEjemplo}
\caption{Editor gráfico y tabular TraceEditor}
\label{fig:TraceEditorEjemplo}
\end{figure}


\subsubsection{El editor gráfico}

Este editor que se puede observar en detalle en la imagen \ref{fig:TraceEditorGrafico}, se compone de un plano principal y una paleta de herramientas. El plano se presenta dividido en 3 zonas en las que se distribuyen los distintos componentes del modelo de \textit{tracelinks} generado:

\begin{itemize}
\item \textsf{\textit{Artefactos orígenes}}, 
\item \textsf{\textit{Transformaciones y trazas}}
\item \textsf{\textit{Artefactos destinos}} 
\end{itemize} 

Las transformaciones se muestran como cajas que contienen los \textit{tracelinks} que se generaron producto de ellas, y las trazas muestran sus relaciones con artefactos orígenes con una línea continua y con los artefactos destinos con una línea de trazos.



\begin{figure}[hbtp]
\centering
\includegraphics[scale=.29]{./img/TraceEditorGrafico}
\caption{El editor gráfico}
\label{fig:TraceEditorGrafico}
\end{figure}


El editor permite:

\begin{itemize}
\item Crear nuevas trazas personalizadas
\item Modificar los identificadores de las transformaciones
\item Modificar los identificadores de los \textit{tracelinks}
\item Definir nuevas relaciones entre los \textit{tracelinks} y los artefactos, y modificar las existentes 
\item Eliminar u ocultar cualquier objeto (transformación, artefacto, relación) con el fin de mejorar un análisis, dado que por lo general los modelos generados por la ejecución de una transformación son muy extensos
\end{itemize}


El editor fue implementado mediante el framework \gls{gmf}, el cual ayuda en la construcción de editores gráficos para un modelo de datos definido. Una descripción con más detalle de esta tecnología se encuentra en la sección \ref{sec:GMF}.


\subsubsection{El editor tabular}
\label{subsubsec:EditorTabular}

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.29]{./img/TraceEditorTabular}
\caption{El editor tabular}
\label{fig:TraceEditorTabular}
\end{figure}

Este editor muestra el mismo modelo de \textit{tracelinks} que se presenta en el editor gráfico que explicamos anteriormente, pero en una lista ordenada tabulado de acuerdo a los siguiente campos:

\begin{itemize}
\item \textsf{\textit{Transformación}}
\item \textsf{\textit{Enlace/Traza}}
\item \textsf{\textit{Tipo de enlace}}
\item \textsf{\textit{Artefacto origen}}
\item \textsf{\textit{Tipo del artefacto origen}}
\item \textsf{\textit{Artefacto destino}}
\item \textsf{\textit{Tipo del artefacto destino}}
\end{itemize}


Una visualización del editor se puede observar en la imagen \ref{fig:TraceEditorTabular}. Con el editor tabular se pueden realizar las siguientes acciones:

\begin{itemize}
\item Renombrar una transformación
\item Renombrar un \textit{tracelink}
\item Renombrar un artefacto
\item Definir o cambiar el tipo de un \textit{tracelink}
\item Definir o cambiar el tipo de un artefacto
\end{itemize}

Este editor en conjunto con la perspectiva que se presenta más adelante, fueron desarrollados con las herramientas provistas por el \gls{pde} de \textsf{Eclipse}.


\subsubsection{La perspectiva}

Como se describe en la subsección de la plataforma \textsf{Eclipse} \ref{subsec:PlatEclipse}, una perspectiva es una agrupación de vistas y editores que en su conjunto ayudan en una actividad completa. En este caso, la perspectiva propuesta para nuestro editor \textsf{TraceEditor} fue ofrecer una vista en la que se presentan los dos editores (el gráfico y el tabular) en forma simultánea dada la complejidad y el volumen de información que puede llegar a presentar un modelo de \textit{tracelinks} cualquiera.


\begin{figure}[hbtp]
\centering
\includegraphics[scale=.29]{./img/TraceEditorPerspectiva}
\caption{Perspectiva del editor}
\label{fig:TraceEditorPerspectiva}
\end{figure}


Para una explicación con más detalle, se presenta en la imagen \ref{fig:TraceEditorPerspectiva} el Workbench \textsf{Eclipse} dividido en cuatro zonas que definen la perspectiva desarrollada:


\paragraph{Zona 1}
En este sector se encuentra el \textsf{Project Explorer} o Explorador de Proyectos, que es una vista de \textsf{Eclipse} que presenta una visual jerárquica de los recursos (proyectos, carpetas y archivos) del Workspace cargados en el Workbench.


\paragraph{Zona 2}
Aquí se presenta la vista \textsf{Outline} de \textsf{Eclipse}, la cual se encarga de mostrar un resumen de la estructura de los elementos del editor activo/seleccionado. En el caso que el activo sea el editor gráfico, esta vista mostrará el gráfico completo del modelo de \textit{tracelinks} que se esté editando y permitirá navegarlo con un recuadro de selección que ofrece.


\paragraph{Zona 3}
Esta zona es el área de edición o editores, es el espacio del Workbench \textsf{Eclipse} asignada para que se muestren todos los editores \textsf{Eclipse} de cualquier tipo. Nuestro editor gráfico se abrirá aquí cuando seleccionemos en el \textsf{Project Explorer} un recurso de tipo diagrama \textsf{TraceEditor}.


\paragraph{Zona 4}
En esta área se muestran, en primer plano el editor tabular titulado \textsf{Lista de Trazas}, presentado anteriormente en esta misma subsección \ref{subsubsec:EditorTabular}, y en segundo plano, la vista de propiedades de \textsf{Eclipse} (\textsf{Properties}) que nos permite ver todas las propiedades de cualquier elemento seleccionado en el editor que se encuentre activo.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% tecnologías %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Descripción de tecnologías}
\markboth{Descripción de tecnologías}{}

\begin{quotation}
En este capítulo se realiza una breve introducción sobre cada una de las tecnologías que fueron utilizadas para la implementación del prototipo que hace uso del esquema propuesto de \textit{traceability}.
\end{quotation}


\bigskip


\minitoc 


\pagebreak


\section{Eclipse}


En la presente sección se introduce al lector en el entorno \textsf{Eclipse}, proyecto base sobre el cual el prototipo va a funcionar y/o ejecutarse. Se describe el proyecto y se detalla brevemente la plataforma con sus principales componentes y/o funcionalidades.


\subsection{El proyecto}

Según se presenta en \cite{EMFADG, Eclipse} \textsf{Eclipse} es un proyecto de desarrollo de software de código abierto, cuyo propósito es proveer una plataforma de herramientas altamente integradas para la construcción, implementación y administración de software a lo largo de todo su ciclo de vida.

El proyecto núcleo es un framework genérico para la integración de herramientas en conjunto con un entorno de desarrollo \textsf{Java} que ya se incluye para usarlo. Otros proyectos extienden el framework núcleo para soportar distintos tipos de herramientas y ambientes de desarrollo específicos. Estos proyectos en \textsf{Eclipse} están implementados en \textsf{Java} y pueden ser ejecutados en muchos sistemas operativos.

La comunidad \textsf{Eclipse} tiene más de 200 proyectos, los cuales pueden organizarse conceptualmente dentro de las siguientes 7 categorías:

\begin{enumerate}

\item Enterprise Development

\item Embedded and Device Development

\item \gls{rcp}

\item \gls{ria}

\item Application Frameworks

\item \gls{alm}

\item \gls{soa}

\end{enumerate}

\textsf{Eclipse} hace uso de la \gls{epl}, dicha licencia comercial permite a las organizaciones incluir software \textsf{Eclipse} en sus productos comerciales, mientras que al mismo tiempo les solicita en retorno un aporte a la comunidad con algo del producto derivado comercializado.


\subsection{La plataforma Eclipse}
\label{subsec:PlatEclipse}

La plataforma \textsf{Eclipse} es un framework para la construcción de \glspl{ide}, el mismo ha sido descripto como ``un ambiente para cualquier cosa y nada en particular''. La plataforma propone simplemente la estructura básica del \gls{ide}, luego mediante la definición de herramientas específicas que amplían y se conectan al framework terminan especificando un \gls{ide} particular de forma colectiva.


\subsubsection{Arquitectura de plugins}

En \textsf{Eclipse} la unidad básica de funcionamiento, o sencillamente un componente, es llamado plug-in. Tanto la plataforma misma de \textsf{Eclipse} como las herramientas que la extienden están compuestas por éstos plug-ins. Una herramienta sencilla puede consistir en un simple plug-in, pero las más complejas por lo general están divididas en varios de éstos.

Un plug-in incluye todo lo necesario para la ejecución del mismo, ésto puede ser: código \textsf{Java}, imágenes, textos, etc. También incluye un archivo manifiesto (\textsf{plugin.xml}), en el que se declaran las interconexiones con otros plug-ins.

Durante el arranque la plataforma \textsf{Eclipse} descubre todos los plug-ins disponibles, sin embargo éstos son sólo activados cuando es necesaria su ejecución con el fin de no ralentizar el arranque.


\subsubsection{Workspace}

Las herramientas integradas en \textsf{Eclipse} trabajan con archivos y carpetas ordinarias, pero también disponen de una \gls{api} de alto nivel que define los siguientes componentes: recursos (\textit{resources}), proyectos y un espacio de trabajo (\textit{workspace}).

\paragraph{Resource} Un recurso es la forma en que \textsf{Eclipse} representa un archivo y/o una carpeta, a los que provee de capacidades adicionales como ser detectores de cambios (\textit{change listeners}), marcadores como por ejemplo las listas por hacer (\textit{to-do list}) y/o mensajes de errores, y un registro de historia de cambios.

\paragraph{Project} Un proyecto es un recurso especial de tipo carpeta que es asignada por el usuario a una carpeta del sistema de archivos, es la que contiene todos los recursos del proyecto y la que define el tipo del mismo.

\paragraph{Workspace} El \textit{workspace} es el espacio de trabajo o contenedor virtual en el que se encuentran todos los proyectos del usuario.


\subsubsection{Workbench}

El \textit{Workbench} es la ventana principal que se le presenta al usuario cuando ejecuta la plataforma \textsf{Eclipse}, se encuentra implementada usando \gls{swt} y JFace. Esta ventana principal, que se puede apreciar en la imagen \ref{fig:EclipseWorkbench} está compuesta de vistas, editores y perspectivas.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.31]{./img/EclipseWorkbench}
\caption{Elcipse Workbench}
\label{fig:EclipseWorkbench}
\end{figure}

\paragraph{Editores} Éstos permiten al usuario abrir, editar y guardar distintos tipos de objectos.

\paragraph{Vistas} Proveen información de algún objeto sobre el que el usuario se encuentra trabajando en el \textit{Workbench}. Por ejemplo, una vista puede asistir a un usuario editor dando información sobre el documento que se está editando.

\paragraph{Perspectivas} Una perspectiva es sencillamente una agrupación de vistas y editores de manera que en su conjunto dan apoyo en una actividad completa.


\subsection{Resumen y más información}

En conclusión, la plataforma \textsf{Eclipse} proporciona un núcleo de elementos básicos y un conjunto de \glspl{api} genéricas, como ser el \textit{workspace} y el \textit{workbench}, y varios puntos de extensión a través del cual se pueden integrar nuevas funcionalidades. A través de estos puntos de extensión, las herramientas escritas como plug-ins independientes pueden extender la plataforma \textsf{Eclipse}.

Para obtener más información sobre el proyecto \textsf{Eclipse} ver \cite[\url{www.eclipse.org}]{Eclipse}, y para información técnica consultar \cite[Eclipse Platform Technical Overview]{EclipseTech}.


\section{Eclipse Modeling Framework}

A continuación se describe una de las tecnologías del proyecto \textsf{Eclipse} usada para la implementación de una parte del prototipo, el framework \gls{emf} \cite{EMF}.

\subsection{El framework EMF}

El \gls{emf} es un framework de modelado y generación de código para herramientas de construcción y otras aplicaciones basadas en un modelo de datos estructurados. A partir de una especificación de un modelo descrito en \gls{xmi}, \gls{emf} provee herramientas y un entorno de ejecución para producir un conjunto de clases \textsf{Java} para el modelo y un conjunto de clases adaptadoras que permiten la visualización y la edición de dicho modelo.

\gls{emf} se conforma de tres partes fundamentales:

\begin{itemize}
\item \textit{EMF}
\item \textit{EMF.Edit}
\item \textit{EMF.Codegen}
\end{itemize}


\subsubsection{EMF}

El framework \gls{emf} base incluye un meta-modelo (\textsf{Ecore}) para la descripción de modelos y un entorno de ejecución para dichos modelos que incluye las funcionalidades de notificación de cambios, persistencia por defecto vía serialización \gls{xmi} y una librería muy eficiente para la manipulación de objectos \gls{emf} genérica.

\subsubsection{EMF.Edit}

El framework EMF.Edit incluye clases genéricas reusables para la construcción de editores de modelos \gls{emf}. Este ofrece:

\begin{itemize}

\item Clases proveedoras de contenido y etiquetas, acceso a propiedades orígenes y otras clases convenientes que permiten a los modelos \gls{emf} ser visualizados mediante entornos gráficos estándares de escritorio (vía \textsf{JFace}) y/o hojas de propiedades.

\item Un framework de comandos que incluye un conjunto de clases que implementan dichos comandos para la construcción de editores con soporte íntegro de deshacer y rehacer (\textsf{undo}/\textsf{redo}).

\end{itemize}

\subsubsection{EMF.Codegen}

La funcionalidad de generación de código \gls{emf} es capaz de producir todo lo necesario para la construcción de un editor de un modelo \gls{emf} completo. Ésta incluye una \gls{gui} desde la cual las opciones de construcción pueden ser especificadas y los generadores invocados. Dicha funcionalidad de generación aprovecha el componente de \textsf{Eclipse} \gls{jdt}.

Tres niveles de generación de código son soportados: 
\begin{itemize}
\item Model
\item Adapters 
\item Editor
\end{itemize}

\paragraph{Model}

Proporciona la implementación de interfaces y clases \textsf{Java} para todas las clases del modelo, además la implementación de una clase fábrica y el paquete.

\paragraph{Adapters}

Genera la implementación de las clases, llamadas \textsf{ItemProviders}, que se adaptan a las clases del modelo para su edición y visualización.

\paragraph{Editor}

Produce un editor estructurado apropiadamente que se ajusta al estilo recomendado para los editores de modelo \gls{emf} de \textsf{Eclipse} y sirve como punto de partida para comenzar con la personalización.


\subsection{El (Meta) modelo Ecore}

\textsf{Ecore} es el modelo usado para representar modelos en \gls{emf}. \textsf{Ecore} es en sí mismo un modelo \gls{emf}, por lo cual es su propio meta-modelo. 

\begin{figure}[hbtp]
\centering
\includegraphics[scale=1]{./img/Ecore}
\caption{Modelo Ecore simplificado}
\label{fig:EcoreModel}
\end{figure}

Un modelo simplificado de \textsf{Ecore} se puede observar en la imagen \ref{fig:EcoreModel}, en particular lo conforman las siguientes cuatro clases \textsf{Ecore} principales:
\begin{itemize}

\item \textsf{EClass}: Usada para representar una clase en el modelo. Tiene un nombre, atributos y referencias.

\item \textsf{EAttribute}: Para representar en el modelo un atributo. Tiene un nombre y un tipo.

\item \textsf{EReference}: Para representar una relación entre clases. Tiene un nombre, una marca que indica si es una composición, y el tipo de clase referenciada u objetivo que es otra clase.

\item \textsf{EDataType}: Representa el tipo de un atributo. El mismo puede ser un tipo primitivo (\textsf{int}, \textsf{float}) o un tipo objeto.

\end{itemize}

\subsection{Beneficios y más información}

Además de incrementar la productividad gracias a la generación automática de código, el uso del framework \gls{emf} provee otros beneficios: la notificación de cambios, una funcionalidad de persistencia (como la serialización \gls{xmi} entre otras), y una \gls{api} genérica reflexiva muy eficiente que sirve para la manipulación de objetos \gls{emf}. Sin embargo, uno de los beneficios más importantes de este framework es que \gls{emf} provee las bases para la interoperabilidad con otras herramientas y aplicaciones que se basan en él. 

Más información sobre el framework \gls{emf} se puede obtener en \cite{EMF} y \cite{EMFADG}.


\section{Graphical Modeling Framework}
\label{sec:GMF}

En la presente sección se analiza el framework \gls{gmf}, el mismo fue usado para el desarrollo de la parte gráfica del editor de \textit{tracelinks} del prototipo.

\subsection{El framework GMF}

\gls{gmf} es un framework para la construcción de editores gráficos de modelado para la plataforma \textsf{Eclipse}, por ejemplo editores \glssymbol{uml}, \textsf{Ecore}, de procesos de negocios, diagramas de flujo, etc. Este framework está conformado por un componente de generación (\textsf{GMF Tooling}) y un entorno de ejecución (\textsf{GMF Runtime}) que ayudan en el desarrollo de editores gráficos que se basan en \gls{emf} y \gls{gef}.

\paragraph{GMF Tooling} incluye por un lado editores para crear y/o modificar los modelos que describen los aspectos de notación, semántica y utilidad de un editor gráfico, y por otro, un generador que da como resultado la implementación del editor definido.

\paragraph{GMF Runtime} Los plug-ins generados con \textsf{GFM-Tooling} dependen de este componente que es el entorno de ejecución sobre el que va a correr el editor.

\subsection{Arquitectura}

En el diagrama de componentes que podemos ver en la figura \ref{fig:GMFArquitectura} se muestran las dependencias existentes entre el editor gráfico generado, el entorno \textsf{GMF Runtime}, \gls{emf}, \gls{gef} y la plataforma \textsf{Eclipse}. Como se puede ver, el editor gráfico \gls{gmf} depende del componente \textsf{GMF Runtime}, y a su vez hace uso directo de \gls{emf}, \gls{gef} y la plataforma \textsf{Eclipse}.


\begin{figure}[hbtp]
\centering
\includegraphics[scale=.75]{./img/GMFArquitectura}
\caption{Arquitectura GMF}
\label{fig:GMFArquitectura}
\end{figure}


\subsection{Modelos y flujo de trabajo}

En el diagrama \ref{fig:GMFWorkflow} se encuentran los principales componentes y modelos usados durante el desarrollo de un editor gráfico mediante el framework \gls{gmf}. Entre ellos se encuentra el concepto de \textbf{modelo de definición gráfica}, el cual contiene toda la información relacionada con los elementos gráficos que formarán parte del editor (figuras, nodos, enlaces, etc), pero que no tiene ninguna conexión directa o no es dependiente de ninguno de los componentes del modelo de dominio para el cual ofrecerá la representación y/o edición. También tenemos el \textbf{modelo de definición de herramientas} que es opcional y usado para el diseño de la paleta, el menú y las barras de herramientas.

Tanto la definición gráfica como la de las herramientas pueden funcionar para modelos variados de dominios, éste es uno de los objetivos de \gls{gmf}, lograr que estas definiciones sean reusables para distintos dominios que se puedan presentar. Lo anterior se logra gracias al uso de un \textbf{modelo de asignación o mapeo}, que se encuentra separado y vincula las definiciones gráficas y las herramientas con los correspondientes modelos de dominios seleccionados.

Una vez que los mapeos o asignaciones son definidos, \gls{gmf} dispone de un \textbf{modelo de generación} el cual posibilita la definición de los detalles para la implementación de la siguiente y última fase, la generación del editor.


\begin{figure}[hbtp]
\centering
\includegraphics[scale=.67]{./img/GMFWorkflow}
\caption{Flujo de trabajo de GMF}
\label{fig:GMFWorkflow}
\end{figure}


\paragraph{Flujo de trabajo}

\begin{enumerate}


\item Creación del modelo del dominio, en este modelo se define la información no gráfica  que gestiona el editor.

\item Creación del \textit{modelo de definición gráfica}, en el que se definen los elementos gráficos que se mostrarán/presentarán en el editor.

\item Creación del \textit{modelo de definición de herramientas}, para definir la paleta, el menú y las barrar de herramientas.

\item Creación del \textit{modelo de asignación gráfica}, que es el que define la correspondencia entre los elementos del modelo del dominio con los elementos gráficos del \textit{modelo de definición gráfica}.

\item Generación del editor gráfico.

\item Mejora del editor gráfico por medio de la edición del código del plug-in generado.

\end{enumerate}


\subsection{Más información}

Más información sobre el framework \gls{gmf} se puede obtener en \cite{GMP}, \cite{IntroGMFRuntime} y \cite{GMFTutorial}.


\section{Atlas Transformation Language}

A continuación se introduce a la tecnología \gls{atl}, que no solo refiere a un lenguaje de transformación de modelos como su nombre puede confundir, sino que además trata de un conjunto de herramientas de desarrollo construidas para ser ejecutadas sobre la Plataforma \textsf{Eclipse} (introducida en \ref{subsec:PlatEclipse}).


\subsection{¿Qué es ATL?}

En el campo de \glssymbol{mde}, \gls{atl} nos ofrece un medio para especificar la forma de producir un conjunto de modelos resultados/destinos a partir de un conjunto de modelos fuentes.

El lenguaje \gls{atl} es un híbrido de la programación declarativa e imperativa, dado que aunque el estilo declarativo es el más conveniente para la definición de las transformaciones, \gls{atl} también provee la posibilidad de construcciones imperativas con el fin de facilitar la especificación de algunos mapeos que en forma declarativa pueden llegar a resultar muy complejos de expresar.

Por otro lado, el \gls{ide} \gls{atl} provee un conjunto de herramientas estándar con el fin de facilitar el desarrollo de las transformaciones mediante este lenguaje como el  resaltado de sintaxis, el auto-completado de código, un depurador, entre otras.



\subsection{Conceptos de ATL}

Un modelo fuente se transforma en un modelo destino gracias a la definición de una transformación escrita en \gls{atl}, la cual a su vez es un modelo en sí mismo. Los modelos fuente, destino y la definición de la transformación, conforman sus respectivos meta-modelos y, a su vez, todos los meta-modelos se ajustan a \gls{mof} o \textsf{Ecore}. Esta relación se puede observar en la imagen \ref{fig:ATL-concepts}.

Una transformación \gls{atl} es unidireccional, o sea que trabaja sobre un modelo fuente de solo lectura y produce un modelo destino de solo escritura. Durante la ejecución de una transformación, el modelo fuente puede ser navegado pero no cambiado, en cambio el modelo destino no puede ser navegado.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.65]{./img/ATL-concepts}
\caption{Modelos, transformaciones y sus meta-modelos}
\label{fig:ATL-concepts}
\end{figure}


\subsection{El lenguaje ATL}

En este lenguaje de transformaciones modelo a modelo o \gls{mmt}, las operaciones de transformación son especificadas mediante módulos \gls{atl}. Cada módulo \gls{atl} permite a un desarrollador especificar la forma de producir un conjunto de modelos resultados desde un conjunto de modelos fuentes/orígenes. 

Además de módulos, este lenguaje permite crear programas que transforman modelos en tipos de datos primitivos (como booleanos, enteros o cadenas), lo cual se logra mediante la especificación de unidades llamadas \gls{atl} queries.

Por último \gls{atl} ofrece la posibilidad de desarrollar librerías independientes que pueden ser importadas a lo largo de diferentes tipos de unidades \glspl{atl}. Ésto nos da una forma conveniente de factorizar el código que va a ser usado por muchas unidades \gls{atl}.


\subsection{Más información}

Más información sobre la tecnología \gls{atl} se puede encontrar en la sección de documentación de la página del proyecto \cite[\url{www.eclipse.org/atl/}]{ATL}.


\section{QVT}
\label{sec:QVT}

Finalizando este capítulo dedicado a las tecnologías que forman parte del trabajo de tesis, se introduce al lenguaje estándar para transformaciones especificado por la \gls{omg}, el lenguaje \gls{qvt}.


\subsection{Introducción a QVT}

\gls{qvt}, como ya se mencionó antes, es el estándar de \gls{omg} para la definición de transformaciones. La especificación de \gls{qvt} es híbrida, como en el caso de \gls{atl}, relacional (o declarativa) y operacional (o imperativa). Comprende tres diferentes lenguajes \gls{mmt}: dos lenguajes declarativos llamados \textsf{Relations} y \textsf{Core}, y un tercer lenguaje, de naturaleza imperativa, llamado \textsf{Operational Mappings}. Puede observarse la relación de los meta-modelos de cada uno de los lenguajes en la figura \ref{fig:QVTmetamodelos}. 

La naturaleza híbrida de este estándar fue introducida para abarcar distintos tipos de usuarios con diferentes necesidades, requisitos y hábitos.

\bigskip

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.65]{./img/metamodelosQVT}
\caption{Relación entre los meta-modelos QVT}
\label{fig:QVTmetamodelos}
\end{figure}


\subsection{Lenguajes QVT}


\subsubsection{QVT declarativo}


\paragraph{Relations}

Es un lenguaje amigable para el usuario, que soporta \textsf{pattern matching} complejo y la creación de templates para objetos. Tiene creación de \textit{tracelinks implícita}. También incluye la propagación de cambios, ya que provee un mecanismo para identificar elementos del modelo destino. 

\paragraph{Core}

Es un lenguaje pequeño con un soporte de \textsf{pattern matching} acotado. Tiene \textit{traceability explícito} y las \textit{tracelinks} pueden crearse y borrarse como cualquier otro objeto. Es igual de poderoso semánticamente que el lenguaje \textsf{Relations} pero trabaja a un nivel más bajo de abstracción. Esta propuesta absolutamente minimal lleva a que el lenguaje \textsf{Core} sea usado como un \textsf{“assembler”} de los lenguajes de transformación.


\subsubsection{QVT imperativo}


\paragraph{Operational Mappings}

Este lenguaje se especificó como una forma estándar para proveer implementaciones imperativas de transformaciones unidireccionales. Al igual que el lenguaje \textsf{Relations}, dispone de creación de \textit{tracelinks implícita} sobre el mismo modelo de \textit{tracelinks}.


\paragraph{Implementaciones Black-box}

Estas implementaciones de caja negra, permiten escribir transformaciones en otro lenguaje distinto a \gls{qvt}. Una implementación de este tipo no tiene relación explicita con el lenguaje \textsf{Relations}. Aunque una caja negra podría implementar una \textsf{Relation}, la misma debe ser responsable de mantener las \textit{tracelinks} entre los elementos relacionados.


\subsection{Más información}

Para obtener más información introductoria consultar \cite{DSDPM}. Para más detalles técnicos y ejemplos se puede leer el documento de especificación \gls{mof} Query/View/Transformation \cite{QVT}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Trabajos relacionados %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Trabajos relacionados}
\markboth{Trabajos relacionados}{} 

\begin{quotation}
En este capítulo se realiza una breve introducción de un conjunto de trabajos que tienen relación con el tema que se desarrolla en la presente tesis, trabajos que encontré durante el proceso de aprendizaje e investigación.
\end{quotation}


\bigskip


\minitoc 


\pagebreak


\section{Un motor de traceability de transformación de modelos en la Ingeniería de Software}

En \cite{AmarLeblancCoulette} se describe un motor de \textit{traceability} al que llamaron ETraceTool, que funciona como un plug-in de \textsf{Eclipse} programado mediante el paradigma orientado a aspectos con el fin de mantener aislada la generación de las tracelinks del código que pertenece a la transformación. El mismo trabaja sobre transformaciones escritas en \textsf{Java} usando la \gls{api} \gls{emf} \cite{EMF}. A continuación se listan sus principales características:

\begin{itemize}
\item El código de generación de tracelinks no es intrusivo en el código de la transformación;
\item La generación de tracelinks tiene que ser activada explícitamente por el diseñador de la transformación;
\item Los modelos de las tracelinks se encuentran aislados de los modelos origen y destino que forman parte de la transformación;
\item Los modelos de las tracelinks pueden ser usados a diferentes niveles de granularidad.
\end{itemize}

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.55]{./img/ETraceTool_Arquitectura}
\caption{Arquitectura de la herramienta ETraceTool}
\label{fig:ArqETraceTool}
\end{figure}

La arquitectura se puede apreciar en el dibujo \ref{fig:ArqETraceTool} y se explica de la siguiente manera, durante la transformación el plug-in captura un conjunto de eventos previamente identificados y clasificados gracias a la programación orientada a aspectos, luego el Aspect Tracer genera un modelo de tracelinks que conforma al meta-modelo de tracelinks anidado que se muestra en el dibujo \ref{fig:ETraceToolMeta-modelo}. Al final, el modelo de tracelinks generado puede ser serializado en un archivo \gls{xmi} o transformado a cualquier otro lenguaje mediante una transformación modelo-texto.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.6]{./img/NestedTraceMetamodel}
\caption{Meta-modelo de tracelinks anidado}
\label{fig:ETraceToolMeta-modelo}
\end{figure}

El fundamento del diseño del meta-modelo de tracelinks anidado propuesto es para el caso en el que se presente una operación de transformación que llama o hace uso de otra transformación. En este caso el enlace compuesto permite separar las operaciones de bajo nivel (creación, eliminación, etc) de las operaciones de alto nivel (como una operación de refactorización).

\section{Un Framework de Traceability dirigido por modelos para el desarrollo de Software Product Line (SPL)}

El framework presentado en \cite{SousaKuleszaRummlerAnquetilMitschkeMoreiraAmaralAraujo} provee una plataforma abierta y flexible para crear enlaces de tracelinks entre distintos artefactos del desarrollo de una \gls{spl}. Pero, dado que el diseño del framework es genérico, éste también puede aplicarse o usarse en otras áreas del desarrollo \gls{spl}. El mismo ha sido diseñado e implementado basándose en el uso de técnicas dirigidas por modelos. El meta-modelo de \textit{traceability} descripto en el dibujo \ref{fig:SPLMeta-modelo} permite definir distintos tipos de enlaces de tracelinks entre los artefactos.

Las principales funcionalidades ofrecidas por el framework son las siguientes:

\begin{enumerate}
\item Creación y mantenimiento de los enlaces de tracelinks de artefactos existentes (modelos \glssymbol{uml}, código fuente, etc);
\item Almacenamiento de los enlaces de tracelinks mediante el uso de un repositorio;
\item Búsqueda de enlaces de tracelinks específicos usando consultas de tracelinks predefinidas o personalizadas;
\item Visualización flexible de los resultados de las consultas de tracelinks por medio de diferentes tipos de vistas, como vista de árbol, grafo, tabla, etc.
\end{enumerate}

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.62]{./img/Traceability_Metamodel}
\caption{Meta-modelo de traceability}
\label{fig:SPLMeta-modelo}
\end{figure}

\subsection{Meta-modelo de traceability}

Los elementos principales del meta-modelo son los siguientes:

\begin{itemize}
\item Un TraceableArtefact representa un artefacto que juega un rol en el ciclo del desarrollo. La granularidad del artefacto es arbitraria, puede ser un requerimiento, un diagrama \glssymbol{uml}, un elemento de dicho diagrama, una clase o un método de dicha clase. El artefacto es identificado mediante la propiedad resourceId.
\item Un TraceLink es la abstracción de una transición de un artefacto a otro.
\item Cada TraceableArtefact tiene asignada una instancia de TraceableArtefactType, éstos se pueden encontrar agrupados de forma jerárquica.
 \item Análogo a los tipos de los artefactos los TraceLinks también tienen un tipo (TraceLinkType), teniendo en cuenta que la semántica de una relación entre dos artefactos puede variar.
\item Información adicional de artefactos y enlaces puede ser modelada mediante un contexto, el cual se encuentra representado por la clase TraceContext.
\item Las restricciones que determinan el conjunto de artefactos válidos, sobre los cuales los tipos de enlaces también son válidos se encuentran modeladas mediante los elementos ScopeArea y Scope.
\end{itemize}

\subsection{Arquitectura}

Como se muestra en el dibujo \ref{fig:SPLArquitectura}, la arquitectura ha sido definida principalmente en término de cuatro módulos. Cada uno de los cuales implementa una de las funcionalidades más importantes del framework. Dichos módulos se detallan a continuación:

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.55]{./img/ArquitecturaTraceabilityFramework}
\caption{Arquitectura del Framework de Traceability}
\label{fig:SPLArquitectura}
\end{figure}

\begin{enumerate}
\item Trace Register: este módulo provee mecanismos para crear y mantener (actualizar, eliminar y buscar) los enlaces de tracelinks;
\item Trace Storage: define los mecanismos de almacenamiento para persistir dichos enlaces;
\item Trace Query: este modulo permite crear y ejecutar consultas para buscar enlaces de tracelinks específicos que se encuentran previamente almacenados;
\item Trace View: usado específicamente para la representación visual de los enlaces resultados de una consulta realizada.
\end{enumerate}


\section{Integración de herramientas Case}

En \cite{KlarRoseSchurr} se presenta el problema real que sufre cualquier proceso de desarrollo actual, en el que como resultado del conjunto de actividades que lo conforman, se genera una variedad muy amplia de artefactos de software (documentos de textos, hojas de cálculo, resultado de pruebas, modelos, gráficos, etc). Estos artefactos, aunque en esencia se encuentran relacionados lógicamente, al ser creados y manipulados por herramientas muy distintas que no fueron pensadas para interactuar (editores de textos, editores de modelo \glssymbol{uml}, etc), las relaciones lógicas nombradas se pierden, o mejor dicho no existen o pasan desapercibidas en la práctica. En otras palabras, se nos presenta el problema de la imposibilidad de \textit{traceability} que encontramos en la mayoría de las herramientas \gls{case} actuales.

Como solución a este problema, se propone un ambiente de integración para las herramientas \gls{case} al que llamaron TiE - Tool Integration Environment, el cual basa su integración en la creación de enlaces de tracelinks entre los artefactos de las distintas herramientas.

\section{Framework genérico de extracción de datos de traceability}

En \cite{GrammelKastenholz} se propone un framework genérico de \textit{traceability} que toma como entrada una transformación de modelo y le aumenta arbitrariamente su funcionalidad con un mecanismo de \textit{traceability}. En el dibujo \ref{fig:GenericoArquitectura} se muestra un panorama de alto nivel de la arquitectura propuesta. Ésta se basa en una interfase genérica que provee un punto de conexión para cualquier motor de transformación de modelos, mediante una \gls{api} que se ofrece al ingeniero que conecta su motor de transformación con el motor de \textit{traceability} (oAW connector, \gls{qvt} connector). Como resultado el motor de transformación incluye la funcionalidad de \textit{traceability}. El modelo de datos que usa el framework es el lenguaje específico de dominio para \textit{traceability} que se denomina Trace-DSL.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.7]{./img/GenericTraceFrame_Arquitectura}
\caption{Resumen de la arquitectura del Framework Genérico de Traceability}
\label{fig:GenericoArquitectura}
\end{figure}


Trace-DSL que se detalla en el dibujo \ref{fig:DSLTrace}, tiene como elemento raíz TraceModel. Artefact representa cualquier producto traceable generado durante el proceso de desarrollo, esto puede ser un requerimiento, una clase o un componente, como por ejemplo el método de una clase. Todo artefacto es identificado unívocamente mediante un identificador universal (UUID). TraceLink es una abstracción de una transición de un artefacto a otro dirigida por la relación desde-hacia entre artefactos origen y destino. TraceLink puede ser de una de las siguientes cuatro instancias: CreateTraceLink, QueryTraceLink, UpdateTraceLink y DeleteTraceLink.


\begin{figure}[hbtp]
\centering
\includegraphics[scale=.93]{./img/Trace-DSL}
\caption{Lenguaje específico de dominio para traceability}
\label{fig:DSLTrace}
\end{figure}

Para la asignación de tipos a los artefactos y a los enlaces se usa el concepto de faceta, donde Trace-DSL asigna un conjunto de facetas (Facet) a cada uno de los mismos. Un ejemplo de faceta se da en el dibujo \ref{fig:FacetaCodigoFuente}. Además de lograr una solución simple al tipado de artefactos y enlaces, se obtiene un mecanismo fácilmente extensible y configurable al contexto donde se necesite aplicar \textit{traceability}.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.72]{./img/Faceta}
\caption{Faceta para traceability de código fuente}
\label{fig:FacetaCodigoFuente}
\end{figure}

La configuración necesaria para hacer uso del framework implica:

\begin{enumerate}
\item Seleccionar las facetas requeridas para el escenario
\item Configurar la granularidad (Granularity) y el alcance (Scope)
\end{enumerate}

La configuración de la granularidad consiste en la especificación de qué tipos (definidos por las facetas) de artefactos y enlaces serán trazados para un escenario de \textit{traceability} particular. En cambio la configuración del alcance implica restringir los datos de \textit{traceability} a una combinación específica de valores. En otras palabras la primera solo chequea la existencia de facetas, mientras que la segunda adicionalmente examina las propiedades especificas de las mismas. Por ejemplo en el caso de TextFileFacet, puede ser necesario trazar solo archivos de textos con cierto nombre.

\section{Traceability local y global}

En la propuesta presentada en \cite{GlitiaEtienDumoulin} se emplea la idea de separación del proceso de \textit{traceability} en los siguientes niveles: \textit{traceability} en lo pequeño y \textit{traceability} en lo grande refiriéndose a los mismos como \textit{traceability} local y \textit{traceability} global respectivamente.

\subsection{Meta-modelo de Traceability Local}

Este meta-modelo toma las tracelinks de la entrada y la salida de una única transformación. El meta-modelo está basado en el meta-modelo de tracelinks presentado en \cite{Jouault} y se muestra en el dibujo \ref{fig:LocalTraceMetamodel}.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.58]{./img/LocalTraceMetamodel}
\caption{Meta-modelo de tracelinks Local}
\label{fig:LocalTraceMetamodel}
\end{figure}

El meta-modelo de tracelinks local contiene dos conceptos principales, Link y ElementRef, los cuales expresan según su definición que uno o más elementos orígenes son enlazados a uno o más elementos objetivos. ElementRef es una clase abstracta que representa elementos que pueden ser traceados: instancias de clases o valores de propiedades. Los valores de las propiedades son traceados usando PrimitivePropertyRef el cual apunta a la instancia contenedora de la propiedad y tiene el nombre de la misma. Este tratamiento especial para los tipos primitivos de \textsf{Java} se debe a que no existen instancias de ellos en el modelo. Por otro lado las propiedades que son tipadas mediante una clase normal, son traceadas mediante ClassRef.

Para almacenar la información sobre las reglas de transformación aplicadas así como el caso particular de las cajas negras, se hace uso de los conceptos RuleRef y BlackBoxRef. En ambos casos, dado que pueden dar como resultado de su ejecución varios enlaces, se define la relación como uno a varios entre RuleRef y Link. RuleRef y BlackBoxRef son opcionales, en el caso de la primera solo se usa para realizar una depuración de las transformaciones, y la segunda si nos encontramos en la situación en la que ciertas partes del sistema no puede ser pública su implementación.

ElementRef tiene una referencia al objeto real de los modelos origen y destinos. Como estos modelos están implementados mediante \gls{emf}, la referencia EMFObject es un EObject del meta-modelo \textsf{Ecore}. La clase LocalTraces representa la raiz del modelo de tracelinks local y tiene un RuleContainer que se usa como contenedor de las reglas y dos ElementContainer usados para agrupar los ElementRef origen y destino respectivamente. Separar los elemento orígenes y destinos permite reducir los costos de búsquedas de elementos de entrada o salida.

\subsection{Meta-modelo de Traceability Global}

Este meta-modelo enlaza tracelinks locales de acuerdo a la cadena que define la transformación. Un modelo de tracelinks global es el punto de entrada principal en el cual todas los modelos de tracelinks locales se encuentran, y describe qué modelo origen/objetivo de una transformación es el modelo objetivo/origen de la siguiente/previa transformación. En el dibujo \ref{fig:GlobalTraceMetamodel} se puede observar el meta-modelo.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.62]{./img/GlobalTraceMetamodel}
\caption{Meta-modelo de tracelinks Global}
\label{fig:GlobalTraceMetamodel}
\end{figure}

En este meta-modelo se engloban todas las tracelinks locales, los modelos de una cadena de transformación y la forma en que éstos se encuentran enlazados mediante TraceModel y LocalModel. Los modelos pueden ser compartidos entre distintas transformaciones, es decir uno puede ser producto de una transformación y también ser consumido por otra transformación.

Introducir este nivel global de tracelinks permite la navegación entre los modelos transformados y sus modelos de tracelinks locales, dando una mejor separación de lo que es en verdad la compleja información de \textit{traceability}, lo que permite además una mejor flexibilidad para la creación de las tracelinks y la explotación de las mismas. No utilizar esta idea de tracelinks globales tiene como consecuencia disponer de todas las tracelinks en un único modelo de toda una cadena de transformación, lo cual desencadenaría en el colapso para la creación y la consulta de dicho modelo.

\subsection{¿Cómo trabaja el framework?}

Uno de los principales objetivos de recolectar las tracelinks es dar luego la posibilidad a un usuario de inspeccionarlas realizando distintas consultas, una de ellas puede ser por ejemplo obtener los elementos relacionados a uno seleccionado. Este meta-modelo permite desde el modelo de tracelinks global navegar hacia los modelos de tracelinks locales y/o hacia a los modelos envueltos en cada una de las transformaciones. También desde el modelo de tracelinks local se puede navegar entre los elementos del modelo parte de la transformación.

En el dibujo \ref{fig:EjemploLocalGlobalMetamodel} se muestra un ejemplo de un modelo de tracelinks locales y globales producto de una cadena de transformación. En el ejemplo se representan los enlaces (Link) entre los elementos sin tener en cuenta las instancias de RuleRef para no sobrecargarlo.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=.46]{./img/EjemploLocalGlobalMetamodel}
\caption{Ejemplo de un modelo de tracelinks local y global}
\label{fig:EjemploLocalGlobalMetamodel}
\end{figure}


\backmatter

% encabezados
\lhead[]{\leftmark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Conclusión %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusión}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Anexos %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\clearpage
\addappheadtotoc
\appendixpage

\chapter{Traceability en ATL}
\label{cap:ATLTtraceability}

La información de \textit{traceability} forma parte del lenguaje \gls{atl}, ésta ayuda en la interacción de cada regla de transformación cuando necesita tomar la salida de alguna otra regla por medio del mecanismo interno de \textit{traceability} implícito. Sin embargo, actualmente \gls{atl} ofrece un acceso muy limitado a dicha información de \textit{traceability} sólo por medio del método \textsf{\textit{resolveTemp()}}. Además, ésta información es eliminada ni bien la ejecución de la transformación termina. Dada las carencias enumeradas anteriormente, para lograr obtener alguna información de \textit{traceability} en esta tecnología es necesario implementar dicha funcionalidad.

Existen varias propuestas de implementación, una de ellas, la que se presenta en \cite{Jouault} en donde se propone considerar como modelos tanto a los programas de transformación como a la información de \textit{traceability}, entonces mediante la definición de una nueva transformación modificar los programas para que generen la información de \textit{traceability} como una salida más al modelo resultado original. Con este enfoque, la generación de código de \textit{traceability} está claramente separada de la lógica de la transformación y la misma se puede agregar después de que un programa haya sido escrito. Por lo cual, es posible añadir el soporte para nuevos formatos o modificar la granularidad o rango de las tracelinks sin interferir con la lógica del programa.

Otras propuestas hacen uso del mecanismo de \textit{traceability} implícito de \gls{atl}, copiando toda la información de tracelinks durante la ejecución de la transformación, o directamente persistiéndola y dejándola accesible en un archivo aparte, pero para todas estas implementaciones se requiere de modificaciones del motor de ejecución de \gls{atl}.




\chapter{QvtoTrace{\textunderscore}To{\textunderscore}Trace}
\label{cap:QvtoTraceToTrace}
\markboth{QvtoTrace{\textunderscore}To{\textunderscore}Trace}{}

A continuación se expone la definición completa de la transformación \gls{qvt} \textsf{QvtoTrace\_To\_Trace} implementada en el prototipo que se desarrolló en la presente Tesis:


\lstdefinelanguage{QVT}{
	morekeywords={
% relations:  
   checkonly, domain, enforce, extends, implementedby, import, key, overrides, primitive, query, relation, top, transformation, when, where
% operational: 
 Bag, Collection, Dict, OrderedSet, Sequence, Set, Tuple, abstract, access, and, any, assert, blackbox, break, case, class, collect, collectNested, collectOne, collectselect, collectselectOne, composes, compute, configuration, constructor, continue, datatype, default, derived, disjuncts, do, elif, else, end, endif, enum, except, exists, extends, exception, false, forAll, forEach, forOne, from, helper, if, implies, import , in, inherits, init, inout, intermediate, invresolve, invresolveIn, invresolveone, invresolveoneIn , isUnique, iterate, late, let, library, literal, log, main, map, mapping, merges, metamodel, modeltype, new, not, null, object, one, or, ordered, out, package, population, primitive, property, query, raise, readonly, references, refines, reject, resolve, resolveIn, resolveone, resolveoneIn, return, select, selectOne, sortedBy, static, switch, tag, then, transformation, true, try, typedef, unlimited, uses, var, when, where, while, with, xcollect , xmap, xor, xselect 
 },
 morecomment=[l]{//},
 morecomment=[s]{/*}{*/},
 morestring=[b]",
 morestring=[d]',
 keywordstyle=\bfseries\color{red},
 commentstyle=\itshape\color{green},
 identifierstyle=\color{black},
 stringstyle=\color{blue}, 
 tabsize=4}
 

\lstset{literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\EUR}}1 {£}{{\pounds}}1
}
\begin{framed}
\lstinputlisting[language=QVT,breaklines=false,mathescape,aboveskip=7mm,breaklines=true,
basicstyle=\footnotesize]{QvtoTrace_To_Trace.qvto}
\end{framed}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Glosario %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printglossaries




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bibliografía %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\addcontentsline{toc}{chapter}{Bibliografía}
\bibliographystyle{acm}
\begin{thebibliography}{99}


\bibitem{IEEE} IEEE Standard Glossary of Software Engineering Terminology. Number Std 610.12-1990, IEEE (1990).

\bibitem{BrcinaRiebisch} R. Brcina and M. Riebisch: Defining a Traceability Link Semantics for Design Decision Support. In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\bibitem{GrammelVoigt} B. Grammel and K. Voigt: Foundations for a Generic Traceability Framework in Model-Driven Software Engineering. In: ECMDA Traceability Workshop (ECMDA-TW) 2009 Proceedings.

\bibitem{Glossary} Glossary of Center of Excellence for Software Traceability (CoEST) \url{http://www.coest.org/index.php/traceability/glossary}.

\bibitem{Excellence} Center of Excellence for Traceability - Problem Statements and Grand Challenges. In: Center of Excellence of Traceability Technical Report (COET-GCT-06-01-0.9) September 10, 2006.

\bibitem{GotelFinkelstein} Gotel, O.C.Z., Finkelstein, A.C.W., “An Analysis of the Requirements Traceability Problem”, International Conference on Requirements Engineering, ICRE’94, Los Alamitos, California, Abril, 1994, pp 94-101.

\bibitem{DrivalosPaigeFernandesKolovos} N. Drivalos, R. F. Paige, K. J. Fernandes, D. S. Kolovos: Towards Rigorously Defined Model-to-Model Traceability. In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\bibitem{GlitiaEtienDumoulin} F. Glitia, A. Etien and C. Dumoulin: Fine Grained Traceability for an MDE Approach of Embedded System Conception. In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\bibitem{Jouault} F. Jouault: Loosely Coupled Traceability for ATL, In: Proceedings of the European Conference on MDA Traceability Workshop, Nurnberg, Germany (2005).

\bibitem{PaigeOlsenKolovosZschalerPower} R. Paige, G. Olsen, D. Kolovos, S. Zschaler, C. Power: Building Model-Driven Engineering Traceability Classifications, In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\bibitem{KlarRoseSchurr} F. Klar, S. Rose, A. Schurr: TiE - A Tool Integration Environment, In: ECMDA Traceability Workshop (ECMDA-TW) 2009 Proceedings.

\bibitem{AbidBotterweck} S. B. Abid, G. Botterweck: Resolving Product Derivation Tasks using Traceability in Software Product Lines, en: ECMDA Traceability Workshop (ECMDA-TW) 2009 Proceedings.

\bibitem{GrammelKastenholz} B. Grammel, S. Kastenholz: A Generic Traceability Framework for Facet-based Traceability Data Extraction in Model-driven Software Development, en: Proceedings of the 6\grad ECMFA Traceability Workshop (ECMFA-TW), 15 de junio de 2010, Paris, Francia.

\bibitem{AmarLeblancCoulette} B. Amar, H. Leblanc, B. Coulette: A Traceability Engine Dedicated to Model Transformation for Software Engineering. In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\bibitem{EMF} Eclipse Modeling Framework Project (EMF) \url{http://www.eclipse.org/modeling/emf/}.

\bibitem{SousaKuleszaRummlerAnquetilMitschkeMoreiraAmaralAraujo} A. Sousa, U. Kulesza, A. Rummler, N. Anquetil, R. Mitschke, A. Moreira, V. Amaral, J. Araújo: A Model-Driven Traceability Framework to Software Product Line Development. In: ECMDA Traceability Workshop (ECMDA-TW) 2008 Proceedings.

\bibitem{Eclipse} Eclipse Project \url{http://www.eclipse.org}.

\bibitem{EclipseTech} Eclipse Platform Technical Overview. Object Technology International, Inc., February 2003,
\url{http://www.eclipse.org/whitepapers/eclipse-overview.pdf}.

\bibitem{EMFADG} F. Budinsky, D. Steinberg, E. Merks, R. Ellersick, T. J. Grose: Eclipse Modeling Framework - A Developer's Guide. Addison Wesley.

\bibitem{GMP} Graphical Modeling Project \url{http://www.eclipse.org/modeling/gmp/}.

\bibitem{IntroGMFRuntime} Frederic Plante, IBM: Introducing the GMF Runtime, January 2006 \url{http://www.eclipse.org/articles/Article-Introducing-GMF/article.html}

\bibitem{GMFTutorial} Graphical Modeling Framework - Tutorial - Part 1 \url{http://wiki.eclipse.org/Graphical_Modeling_Framework/Tutorial/Part_1}

\bibitem{ATL} ATL Eclipse Project \url{http://www.eclipse.org/atl/}.

\bibitem{QVT} Meta Object Facility (MOF) 2.0 Query/View/Transformation Specification. Version 1.1, January 2011 - Version 1.0, April 2008. \url{http://www.omg.org/spec/QVT/index.htm}.

\bibitem{DSDPM} C. Pons, R. Giandini y G. Pérez: Desarrollo de Software Dirigido por Modelos. Conceptos teóricos y su aplicación práctica. Facultad de Informática, Universidad Nacional de La Plata. Octubre de 2008.

\bibitem{DSIS} Pierre F. Tiako: Designing Software-Intensive Systems, Methods and Principles. Langston University, USA. 2008.

\end{thebibliography}


\end{document}
