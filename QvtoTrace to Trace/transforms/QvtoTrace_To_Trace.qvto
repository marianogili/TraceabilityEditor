modeltype TraceEditor uses 'http://traceeditor/TraceEditor';
modeltype QvtoTrace uses 'http:///www.eclipse.org/m2m/qvt/operational/trace.ecore';
		

transformation QvtoTrace_To_Trace(in qvto : QvtoTrace, out TraceEditor);

main() {
	qvto.rootObjects()[QvtoTrace::Trace]->map trace2TraceEditor();
}

mapping QvtoTrace::Trace::trace2TraceEditor() : TraceEditor::TraceEditor {
 	_configuration := self.map trace2Configuration();
 	dashboard :=  self.map trace2Dashboard();
}

mapping QvtoTrace::Trace::trace2Configuration() : TraceEditor::Configuration {
	//TODO: crear tipos coherentes para las transformaciones QVT.
	linkTypes := OrderedSet{};
	typeArtefacts := self.TypesByName()->collect(n | object TraceEditor::TypeArtefact {
		name := n;
		description := "";
	}); 
}

mapping QvtoTrace::Trace::trace2Dashboard() : TraceEditor::Dashboard {
	transformations := self.TransformationsByName()->collect(t | object TraceEditor::Transformation {
		name := t;
		traceLinks := self.traceRecords[mappingOperation.name=t]->map traceRecord2TraceLink();
	});
	// dado que las trazas de QVT son todas producto de transformaciones, la colección traceLinks se inicializa vacía.
	traceLinks := OrderedSet{};
	sourceArtefacts := self.traceRecords._context._context[name="self"].map varParameterValue2Artefact("Source");
	targetArtefacts := self.traceRecords._result._result.map varParameterValue2Artefact("Target");
}

mapping QvtoTrace::TraceRecord::traceRecord2TraceLink() : TraceEditor::TraceLink {
	name := self.repr();
	_transformation := result.container().oclAsType(TraceEditor::Transformation);
	sources := self._context._context[name="self"].map varParameterValue2Artefact("Source");
	targets := self._result._result->map varParameterValue2Artefact("Target")->flatten(); 
}

mapping QvtoTrace::VarParameterValue::varParameterValue2Artefact(in prefix : String) : OrderedSet(TraceEditor::Artefact) 
	disjuncts QvtoTrace::VarParameterValue::varParameterValueSimple2Artefact, 
		QvtoTrace::VarParameterValue::varParameterValueCollection2Artefact {}

mapping QvtoTrace::VarParameterValue::varParameterValueSimple2Artefact(in prefix : String) : OrderedSet(TraceEditor::Artefact) 
	when { self.value.collectionType = null } {
		init {
			result := object TraceEditor::Artefact {
				name := self.value.repr();
				type := self.container().container().container().oclAsType(QvtoTrace::Trace).resolveoneIn(
					QvtoTrace::Trace::trace2Configuration,
					TraceEditor::Configuration
				).typeArtefacts![name = self.type.prefix(prefix)];
			}->asOrderedSet();
		}
}

mapping QvtoTrace::VarParameterValue::varParameterValueCollection2Artefact(in prefix : String) : OrderedSet(TraceEditor::Artefact) 
	when { self.value.collectionType <> null } {
		init {
			result := self.value.collection->collect(e | object TraceEditor::Artefact {
				name := e.repr();
				//TODO: obtener el tipo del artefacto y asociarlo. Una opción es sacar el nombre de la colección y otra ver tema blackboxes.
				//type := e.container().oclAsType(QvtoTrace::VarParameterValue).type
			})->asOrderedSet();
		}
}

helper String::prefix(in pre : String) : String {
	return pre + "_" + self;
}

/*
 * Retorna el conjunto de nombres de los distintos tipos de artefactos que se encuentran en el registro de trazas.
 */
query QvtoTrace::Trace::TypesByName() : OrderedSet(String) {
	//TODO: ver si es necesario un tratamiento especial para obtener los tipos.
	return self.traceRecords._context._context[name="self"].type.prefix("Source")->asSet()->union(
		self.traceRecords._result._result[name="result" and value.collectionType = null].type.prefix("Target")->asSet()
	)->asOrderedSet();
}

/*
 * Retorna el conjunto de transformaciones de las distintas trazas que se encuentran en el registro.
 */
query QvtoTrace::Trace::TransformationsByName() : OrderedSet(String) {
	return self.traceRecords.mappingOperation.name->asOrderedSet();
}

