modeltype TraceEditor uses 'http://traceeditor/TraceEditor';
modeltype QvtoTrace uses 'http:///www.eclipse.org/m2m/qvt/operational/trace.ecore';
		

transformation QvtoTrace_To_Trace(in qvto : QvtoTrace, out TraceEditor);

main() {
	qvto.rootObjects()[QvtoTrace::Trace]->map trace2TraceEditor();
}

mapping QvtoTrace::Trace::trace2TraceEditor() : TraceEditor::TraceEditor {
 	_configuration := self.map trace2Configuration();
 	dashboard :=  self.map trace2Dashboard();
}

mapping QvtoTrace::Trace::trace2Configuration() : TraceEditor::Configuration {
	//TODO: crear tipos coherentes a las transformaciones QVT.
	linkTypes := OrderedSet{};
	typeArtefacts := self.TypesByName()->collect(n | object TraceEditor::TypeArtefact {
		name := n;
		description := "una descrip.";
	}); 
}

mapping QvtoTrace::Trace::trace2Dashboard() : TraceEditor::Dashboard {
	transformations := self.MappingsOperationsByName()->map mappingOperation2Transformation();
	// dado que las trazas de QVT son todas producto de transformaciones, la colección traceLinks se inicializa vacía.
	traceLinks := OrderedSet{};
	// TODO: acotar los sources a los contextos con name='self'
	sourceArtefacts := self.traceRecords._context._context.map varParameterValue2Artefact();
	targetArtefacts := self.traceRecords._result._result->map varParameterValue2Artefact(); 
}

mapping QvtoTrace::VarParameterValue::varParameterValue2Artefact() : TraceEditor::Artefact {
	name := self.value.repr();
	type := self.container().container().container().oclAsType(QvtoTrace::Trace).resolveoneIn(
		QvtoTrace::Trace::trace2Configuration,
		TraceEditor::Configuration
	).typeArtefacts![name = self.type]; 
}

mapping QvtoTrace::EMappingOperation::mappingOperation2Transformation() : TraceEditor::Transformation {
	name := self.name;
	traceLinks := self.container().container().oclAsType(QvtoTrace::Trace).TraceRecordsForMappingsOperationsByName(result.name)->
		map traceRecord2TraceLink();
}

mapping QvtoTrace::TraceRecord::traceRecord2TraceLink() : TraceEditor::TraceLink {
	name := self.mappingOperation.name;
	// TODO: ver si ésto está bien
	_transformation := self.container().oclAsType(QvtoTrace::Trace).TraceRecordsForMappingsOperationsByName(result.name).resolveoneIn(
			QvtoTrace::EMappingOperation::mappingOperation2Transformation,
			TraceEditor::Transformation);
	sources := self._context._context.late resolveIn(
		QvtoTrace::VarParameterValue::varParameterValue2Artefact,
		TraceEditor::Artefact
	);
	targets := self._result._result.late resolveIn(
		QvtoTrace::VarParameterValue::varParameterValue2Artefact,
		TraceEditor::Artefact
	); 
}


/*
 * Retorna el listado de trazas para las operaciones que sean del nombre parámetro.
 */
helper QvtoTrace::Trace::TraceRecordsForMappingsOperationsByName(in operationName : String) : Set(QvtoTrace::TraceRecord) {
	var traces := self.traceRecords->select(t | t.mappingOperation.name = operationName);
	return traces;
}

/*
 * Retorna el conjunto de nombres de los distintos tipos de artefactos que se encuentran en el registro de trazas.
 */
query QvtoTrace::Trace::TypesByName() : OrderedSet(String) {
	//TODO: ver si es necesario un tratamiento especial para obtener los tipos.
	return self.traceRecords._context._context[name="self"].type->asSet()->union(
		self.traceRecords._result._result[name="result" and value.collectionType = null].type->asSet()
	)->asOrderedSet();
}

/*
 * Retorna el listado de operaciones sin repeticiones por nombre.
 */
helper QvtoTrace::Trace::MappingsOperationsByName() : List(QvtoTrace::EMappingOperation) {
	var names := self.traceRecords.mappingOperation->collect(name)->asSet();
	var res : List(QvtoTrace::EMappingOperation) := List{};
	names->forEach(n){
		var temp := self.traceRecords.mappingOperation->select(m | m.name = n)->first();
		res->append(temp);
	};
	return res;
}